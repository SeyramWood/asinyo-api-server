// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/SeyramWood/app/domain/models"
	"github.com/SeyramWood/ent/address"
	"github.com/SeyramWood/ent/admin"
	"github.com/SeyramWood/ent/agent"
	"github.com/SeyramWood/ent/agentrequest"
	"github.com/SeyramWood/ent/customer"
	"github.com/SeyramWood/ent/favourite"
	"github.com/SeyramWood/ent/merchant"
	"github.com/SeyramWood/ent/merchantstore"
	"github.com/SeyramWood/ent/order"
	"github.com/SeyramWood/ent/orderdetail"
	"github.com/SeyramWood/ent/pickupstation"
	"github.com/SeyramWood/ent/predicate"
	"github.com/SeyramWood/ent/product"
	"github.com/SeyramWood/ent/productcategorymajor"
	"github.com/SeyramWood/ent/productcategoryminor"
	"github.com/SeyramWood/ent/retailmerchant"
	"github.com/SeyramWood/ent/suppliermerchant"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddress              = "Address"
	TypeAdmin                = "Admin"
	TypeAgent                = "Agent"
	TypeAgentRequest         = "AgentRequest"
	TypeCustomer             = "Customer"
	TypeFavourite            = "Favourite"
	TypeMerchant             = "Merchant"
	TypeMerchantStore        = "MerchantStore"
	TypeOrder                = "Order"
	TypeOrderDetail          = "OrderDetail"
	TypePickupStation        = "PickupStation"
	TypeProduct              = "Product"
	TypeProductCategoryMajor = "ProductCategoryMajor"
	TypeProductCategoryMinor = "ProductCategoryMinor"
	TypeRetailMerchant       = "RetailMerchant"
	TypeSupplierMerchant     = "SupplierMerchant"
)

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	last_name         *string
	other_name        *string
	phone             *string
	other_phone       *string
	digital_address   *string
	city              *string
	_Region           *string
	address           *string
	other_information *string
	_default          *bool
	clearedFields     map[string]struct{}
	merchant          *int
	clearedmerchant   bool
	agent             *int
	clearedagent      bool
	customer          *int
	clearedcustomer   bool
	orders            map[int]struct{}
	removedorders     map[int]struct{}
	clearedorders     bool
	done              bool
	oldValue          func(context.Context) (*Address, error)
	predicates        []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id int) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AddressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastName sets the "last_name" field.
func (m *AddressMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AddressMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AddressMutation) ResetLastName() {
	m.last_name = nil
}

// SetOtherName sets the "other_name" field.
func (m *AddressMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *AddressMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *AddressMutation) ResetOtherName() {
	m.other_name = nil
}

// SetPhone sets the "phone" field.
func (m *AddressMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AddressMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *AddressMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *AddressMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *AddressMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldOtherPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *AddressMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[address.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *AddressMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[address.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *AddressMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, address.FieldOtherPhone)
}

// SetDigitalAddress sets the "digital_address" field.
func (m *AddressMutation) SetDigitalAddress(s string) {
	m.digital_address = &s
}

// DigitalAddress returns the value of the "digital_address" field in the mutation.
func (m *AddressMutation) DigitalAddress() (r string, exists bool) {
	v := m.digital_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDigitalAddress returns the old "digital_address" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldDigitalAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigitalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigitalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigitalAddress: %w", err)
	}
	return oldValue.DigitalAddress, nil
}

// ClearDigitalAddress clears the value of the "digital_address" field.
func (m *AddressMutation) ClearDigitalAddress() {
	m.digital_address = nil
	m.clearedFields[address.FieldDigitalAddress] = struct{}{}
}

// DigitalAddressCleared returns if the "digital_address" field was cleared in this mutation.
func (m *AddressMutation) DigitalAddressCleared() bool {
	_, ok := m.clearedFields[address.FieldDigitalAddress]
	return ok
}

// ResetDigitalAddress resets all changes to the "digital_address" field.
func (m *AddressMutation) ResetDigitalAddress() {
	m.digital_address = nil
	delete(m.clearedFields, address.FieldDigitalAddress)
}

// SetCity sets the "city" field.
func (m *AddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AddressMutation) ResetCity() {
	m.city = nil
}

// SetRegion sets the "Region" field.
func (m *AddressMutation) SetRegion(s string) {
	m._Region = &s
}

// Region returns the value of the "Region" field in the mutation.
func (m *AddressMutation) Region() (r string, exists bool) {
	v := m._Region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "Region" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "Region" field.
func (m *AddressMutation) ResetRegion() {
	m._Region = nil
}

// SetAddress sets the "address" field.
func (m *AddressMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AddressMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AddressMutation) ResetAddress() {
	m.address = nil
}

// SetOtherInformation sets the "other_information" field.
func (m *AddressMutation) SetOtherInformation(s string) {
	m.other_information = &s
}

// OtherInformation returns the value of the "other_information" field in the mutation.
func (m *AddressMutation) OtherInformation() (r string, exists bool) {
	v := m.other_information
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherInformation returns the old "other_information" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldOtherInformation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherInformation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherInformation: %w", err)
	}
	return oldValue.OtherInformation, nil
}

// ClearOtherInformation clears the value of the "other_information" field.
func (m *AddressMutation) ClearOtherInformation() {
	m.other_information = nil
	m.clearedFields[address.FieldOtherInformation] = struct{}{}
}

// OtherInformationCleared returns if the "other_information" field was cleared in this mutation.
func (m *AddressMutation) OtherInformationCleared() bool {
	_, ok := m.clearedFields[address.FieldOtherInformation]
	return ok
}

// ResetOtherInformation resets all changes to the "other_information" field.
func (m *AddressMutation) ResetOtherInformation() {
	m.other_information = nil
	delete(m.clearedFields, address.FieldOtherInformation)
}

// SetDefault sets the "default" field.
func (m *AddressMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *AddressMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *AddressMutation) ResetDefault() {
	m._default = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *AddressMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *AddressMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *AddressMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *AddressMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *AddressMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *AddressMutation) SetAgentID(id int) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *AddressMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *AddressMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *AddressMutation) AgentID() (id int, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) AgentIDs() (ids []int) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *AddressMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *AddressMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *AddressMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *AddressMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *AddressMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *AddressMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *AddressMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *AddressMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *AddressMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *AddressMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *AddressMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *AddressMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *AddressMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, address.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, address.FieldUpdatedAt)
	}
	if m.last_name != nil {
		fields = append(fields, address.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, address.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, address.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, address.FieldOtherPhone)
	}
	if m.digital_address != nil {
		fields = append(fields, address.FieldDigitalAddress)
	}
	if m.city != nil {
		fields = append(fields, address.FieldCity)
	}
	if m._Region != nil {
		fields = append(fields, address.FieldRegion)
	}
	if m.address != nil {
		fields = append(fields, address.FieldAddress)
	}
	if m.other_information != nil {
		fields = append(fields, address.FieldOtherInformation)
	}
	if m._default != nil {
		fields = append(fields, address.FieldDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldCreatedAt:
		return m.CreatedAt()
	case address.FieldUpdatedAt:
		return m.UpdatedAt()
	case address.FieldLastName:
		return m.LastName()
	case address.FieldOtherName:
		return m.OtherName()
	case address.FieldPhone:
		return m.Phone()
	case address.FieldOtherPhone:
		return m.OtherPhone()
	case address.FieldDigitalAddress:
		return m.DigitalAddress()
	case address.FieldCity:
		return m.City()
	case address.FieldRegion:
		return m.Region()
	case address.FieldAddress:
		return m.Address()
	case address.FieldOtherInformation:
		return m.OtherInformation()
	case address.FieldDefault:
		return m.Default()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case address.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case address.FieldLastName:
		return m.OldLastName(ctx)
	case address.FieldOtherName:
		return m.OldOtherName(ctx)
	case address.FieldPhone:
		return m.OldPhone(ctx)
	case address.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case address.FieldDigitalAddress:
		return m.OldDigitalAddress(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldRegion:
		return m.OldRegion(ctx)
	case address.FieldAddress:
		return m.OldAddress(ctx)
	case address.FieldOtherInformation:
		return m.OldOtherInformation(ctx)
	case address.FieldDefault:
		return m.OldDefault(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case address.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case address.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case address.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case address.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case address.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case address.FieldDigitalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigitalAddress(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case address.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case address.FieldOtherInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherInformation(v)
		return nil
	case address.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldOtherPhone) {
		fields = append(fields, address.FieldOtherPhone)
	}
	if m.FieldCleared(address.FieldDigitalAddress) {
		fields = append(fields, address.FieldDigitalAddress)
	}
	if m.FieldCleared(address.FieldOtherInformation) {
		fields = append(fields, address.FieldOtherInformation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	case address.FieldDigitalAddress:
		m.ClearDigitalAddress()
		return nil
	case address.FieldOtherInformation:
		m.ClearOtherInformation()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case address.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case address.FieldLastName:
		m.ResetLastName()
		return nil
	case address.FieldOtherName:
		m.ResetOtherName()
		return nil
	case address.FieldPhone:
		m.ResetPhone()
		return nil
	case address.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case address.FieldDigitalAddress:
		m.ResetDigitalAddress()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldRegion:
		m.ResetRegion()
		return nil
	case address.FieldAddress:
		m.ResetAddress()
		return nil
	case address.FieldOtherInformation:
		m.ResetOtherInformation()
		return nil
	case address.FieldDefault:
		m.ResetDefault()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.merchant != nil {
		edges = append(edges, address.EdgeMerchant)
	}
	if m.agent != nil {
		edges = append(edges, address.EdgeAgent)
	}
	if m.customer != nil {
		edges = append(edges, address.EdgeCustomer)
	}
	if m.orders != nil {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedorders != nil {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmerchant {
		edges = append(edges, address.EdgeMerchant)
	}
	if m.clearedagent {
		edges = append(edges, address.EdgeAgent)
	}
	if m.clearedcustomer {
		edges = append(edges, address.EdgeCustomer)
	}
	if m.clearedorders {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeMerchant:
		return m.clearedmerchant
	case address.EdgeAgent:
		return m.clearedagent
	case address.EdgeCustomer:
		return m.clearedcustomer
	case address.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	case address.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case address.EdgeAgent:
		m.ClearAgent()
		return nil
	case address.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case address.EdgeAgent:
		m.ResetAgent()
		return nil
	case address.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case address.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	username      *string
	password      *[]byte
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Admin, error)
	predicates    []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *AdminMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdminMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminMutation) ResetPassword() {
	m.password = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, admin.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, admin.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	case admin.FieldUsername:
		return m.Username()
	case admin.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admin.FieldUsername:
		return m.OldUsername(ctx)
	case admin.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case admin.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admin.FieldUsername:
		m.ResetUsername()
		return nil
	case admin.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	username          *string
	password          *[]byte
	ghana_card        *string
	last_name         *string
	other_name        *string
	phone             *string
	other_phone       *string
	address           *string
	digital_address   *string
	region            *string
	district          *string
	city              *string
	default_account   *agent.DefaultAccount
	bank_account      **models.MerchantBankAccount
	momo_account      **models.MerchantMomoAccount
	verified          *bool
	compliance        **models.AgentComplianceModel
	clearedFields     map[string]struct{}
	addresses         map[int]struct{}
	removedaddresses  map[int]struct{}
	clearedaddresses  bool
	orders            map[int]struct{}
	removedorders     map[int]struct{}
	clearedorders     bool
	favourites        map[int]struct{}
	removedfavourites map[int]struct{}
	clearedfavourites bool
	store             map[int]struct{}
	removedstore      map[int]struct{}
	clearedstore      bool
	requests          map[int]struct{}
	removedrequests   map[int]struct{}
	clearedrequests   bool
	done              bool
	oldValue          func(context.Context) (*Agent, error)
	predicates        []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id int) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *AgentMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AgentMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AgentMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AgentMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *AgentMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AgentMutation) ResetPassword() {
	m.password = nil
}

// SetGhanaCard sets the "ghana_card" field.
func (m *AgentMutation) SetGhanaCard(s string) {
	m.ghana_card = &s
}

// GhanaCard returns the value of the "ghana_card" field in the mutation.
func (m *AgentMutation) GhanaCard() (r string, exists bool) {
	v := m.ghana_card
	if v == nil {
		return
	}
	return *v, true
}

// OldGhanaCard returns the old "ghana_card" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldGhanaCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGhanaCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGhanaCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGhanaCard: %w", err)
	}
	return oldValue.GhanaCard, nil
}

// ResetGhanaCard resets all changes to the "ghana_card" field.
func (m *AgentMutation) ResetGhanaCard() {
	m.ghana_card = nil
}

// SetLastName sets the "last_name" field.
func (m *AgentMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AgentMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AgentMutation) ResetLastName() {
	m.last_name = nil
}

// SetOtherName sets the "other_name" field.
func (m *AgentMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *AgentMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *AgentMutation) ResetOtherName() {
	m.other_name = nil
}

// SetPhone sets the "phone" field.
func (m *AgentMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AgentMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *AgentMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *AgentMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *AgentMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOtherPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *AgentMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[agent.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *AgentMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[agent.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *AgentMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, agent.FieldOtherPhone)
}

// SetAddress sets the "address" field.
func (m *AgentMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AgentMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AgentMutation) ResetAddress() {
	m.address = nil
}

// SetDigitalAddress sets the "digital_address" field.
func (m *AgentMutation) SetDigitalAddress(s string) {
	m.digital_address = &s
}

// DigitalAddress returns the value of the "digital_address" field in the mutation.
func (m *AgentMutation) DigitalAddress() (r string, exists bool) {
	v := m.digital_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDigitalAddress returns the old "digital_address" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDigitalAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigitalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigitalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigitalAddress: %w", err)
	}
	return oldValue.DigitalAddress, nil
}

// ResetDigitalAddress resets all changes to the "digital_address" field.
func (m *AgentMutation) ResetDigitalAddress() {
	m.digital_address = nil
}

// SetRegion sets the "region" field.
func (m *AgentMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *AgentMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldRegion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ClearRegion clears the value of the "region" field.
func (m *AgentMutation) ClearRegion() {
	m.region = nil
	m.clearedFields[agent.FieldRegion] = struct{}{}
}

// RegionCleared returns if the "region" field was cleared in this mutation.
func (m *AgentMutation) RegionCleared() bool {
	_, ok := m.clearedFields[agent.FieldRegion]
	return ok
}

// ResetRegion resets all changes to the "region" field.
func (m *AgentMutation) ResetRegion() {
	m.region = nil
	delete(m.clearedFields, agent.FieldRegion)
}

// SetDistrict sets the "district" field.
func (m *AgentMutation) SetDistrict(s string) {
	m.district = &s
}

// District returns the value of the "district" field in the mutation.
func (m *AgentMutation) District() (r string, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrict returns the old "district" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDistrict(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrict: %w", err)
	}
	return oldValue.District, nil
}

// ClearDistrict clears the value of the "district" field.
func (m *AgentMutation) ClearDistrict() {
	m.district = nil
	m.clearedFields[agent.FieldDistrict] = struct{}{}
}

// DistrictCleared returns if the "district" field was cleared in this mutation.
func (m *AgentMutation) DistrictCleared() bool {
	_, ok := m.clearedFields[agent.FieldDistrict]
	return ok
}

// ResetDistrict resets all changes to the "district" field.
func (m *AgentMutation) ResetDistrict() {
	m.district = nil
	delete(m.clearedFields, agent.FieldDistrict)
}

// SetCity sets the "city" field.
func (m *AgentMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AgentMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *AgentMutation) ClearCity() {
	m.city = nil
	m.clearedFields[agent.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *AgentMutation) CityCleared() bool {
	_, ok := m.clearedFields[agent.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *AgentMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, agent.FieldCity)
}

// SetDefaultAccount sets the "default_account" field.
func (m *AgentMutation) SetDefaultAccount(aa agent.DefaultAccount) {
	m.default_account = &aa
}

// DefaultAccount returns the value of the "default_account" field in the mutation.
func (m *AgentMutation) DefaultAccount() (r agent.DefaultAccount, exists bool) {
	v := m.default_account
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultAccount returns the old "default_account" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDefaultAccount(ctx context.Context) (v agent.DefaultAccount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultAccount: %w", err)
	}
	return oldValue.DefaultAccount, nil
}

// ClearDefaultAccount clears the value of the "default_account" field.
func (m *AgentMutation) ClearDefaultAccount() {
	m.default_account = nil
	m.clearedFields[agent.FieldDefaultAccount] = struct{}{}
}

// DefaultAccountCleared returns if the "default_account" field was cleared in this mutation.
func (m *AgentMutation) DefaultAccountCleared() bool {
	_, ok := m.clearedFields[agent.FieldDefaultAccount]
	return ok
}

// ResetDefaultAccount resets all changes to the "default_account" field.
func (m *AgentMutation) ResetDefaultAccount() {
	m.default_account = nil
	delete(m.clearedFields, agent.FieldDefaultAccount)
}

// SetBankAccount sets the "bank_account" field.
func (m *AgentMutation) SetBankAccount(mba *models.MerchantBankAccount) {
	m.bank_account = &mba
}

// BankAccount returns the value of the "bank_account" field in the mutation.
func (m *AgentMutation) BankAccount() (r *models.MerchantBankAccount, exists bool) {
	v := m.bank_account
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccount returns the old "bank_account" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldBankAccount(ctx context.Context) (v *models.MerchantBankAccount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccount: %w", err)
	}
	return oldValue.BankAccount, nil
}

// ClearBankAccount clears the value of the "bank_account" field.
func (m *AgentMutation) ClearBankAccount() {
	m.bank_account = nil
	m.clearedFields[agent.FieldBankAccount] = struct{}{}
}

// BankAccountCleared returns if the "bank_account" field was cleared in this mutation.
func (m *AgentMutation) BankAccountCleared() bool {
	_, ok := m.clearedFields[agent.FieldBankAccount]
	return ok
}

// ResetBankAccount resets all changes to the "bank_account" field.
func (m *AgentMutation) ResetBankAccount() {
	m.bank_account = nil
	delete(m.clearedFields, agent.FieldBankAccount)
}

// SetMomoAccount sets the "momo_account" field.
func (m *AgentMutation) SetMomoAccount(mma *models.MerchantMomoAccount) {
	m.momo_account = &mma
}

// MomoAccount returns the value of the "momo_account" field in the mutation.
func (m *AgentMutation) MomoAccount() (r *models.MerchantMomoAccount, exists bool) {
	v := m.momo_account
	if v == nil {
		return
	}
	return *v, true
}

// OldMomoAccount returns the old "momo_account" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldMomoAccount(ctx context.Context) (v *models.MerchantMomoAccount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMomoAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMomoAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMomoAccount: %w", err)
	}
	return oldValue.MomoAccount, nil
}

// ClearMomoAccount clears the value of the "momo_account" field.
func (m *AgentMutation) ClearMomoAccount() {
	m.momo_account = nil
	m.clearedFields[agent.FieldMomoAccount] = struct{}{}
}

// MomoAccountCleared returns if the "momo_account" field was cleared in this mutation.
func (m *AgentMutation) MomoAccountCleared() bool {
	_, ok := m.clearedFields[agent.FieldMomoAccount]
	return ok
}

// ResetMomoAccount resets all changes to the "momo_account" field.
func (m *AgentMutation) ResetMomoAccount() {
	m.momo_account = nil
	delete(m.clearedFields, agent.FieldMomoAccount)
}

// SetVerified sets the "verified" field.
func (m *AgentMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *AgentMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *AgentMutation) ResetVerified() {
	m.verified = nil
}

// SetCompliance sets the "compliance" field.
func (m *AgentMutation) SetCompliance(mcm *models.AgentComplianceModel) {
	m.compliance = &mcm
}

// Compliance returns the value of the "compliance" field in the mutation.
func (m *AgentMutation) Compliance() (r *models.AgentComplianceModel, exists bool) {
	v := m.compliance
	if v == nil {
		return
	}
	return *v, true
}

// OldCompliance returns the old "compliance" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCompliance(ctx context.Context) (v *models.AgentComplianceModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompliance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompliance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompliance: %w", err)
	}
	return oldValue.Compliance, nil
}

// ClearCompliance clears the value of the "compliance" field.
func (m *AgentMutation) ClearCompliance() {
	m.compliance = nil
	m.clearedFields[agent.FieldCompliance] = struct{}{}
}

// ComplianceCleared returns if the "compliance" field was cleared in this mutation.
func (m *AgentMutation) ComplianceCleared() bool {
	_, ok := m.clearedFields[agent.FieldCompliance]
	return ok
}

// ResetCompliance resets all changes to the "compliance" field.
func (m *AgentMutation) ResetCompliance() {
	m.compliance = nil
	delete(m.clearedFields, agent.FieldCompliance)
}

// AddAddressIDs adds the "addresses" edge to the Address entity by ids.
func (m *AgentMutation) AddAddressIDs(ids ...int) {
	if m.addresses == nil {
		m.addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *AgentMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *AgentMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the Address entity by IDs.
func (m *AgentMutation) RemoveAddressIDs(ids ...int) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the Address entity.
func (m *AgentMutation) RemovedAddressesIDs() (ids []int) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *AgentMutation) AddressesIDs() (ids []int) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *AgentMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *AgentMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *AgentMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *AgentMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *AgentMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *AgentMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *AgentMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *AgentMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddFavouriteIDs adds the "favourites" edge to the Favourite entity by ids.
func (m *AgentMutation) AddFavouriteIDs(ids ...int) {
	if m.favourites == nil {
		m.favourites = make(map[int]struct{})
	}
	for i := range ids {
		m.favourites[ids[i]] = struct{}{}
	}
}

// ClearFavourites clears the "favourites" edge to the Favourite entity.
func (m *AgentMutation) ClearFavourites() {
	m.clearedfavourites = true
}

// FavouritesCleared reports if the "favourites" edge to the Favourite entity was cleared.
func (m *AgentMutation) FavouritesCleared() bool {
	return m.clearedfavourites
}

// RemoveFavouriteIDs removes the "favourites" edge to the Favourite entity by IDs.
func (m *AgentMutation) RemoveFavouriteIDs(ids ...int) {
	if m.removedfavourites == nil {
		m.removedfavourites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favourites, ids[i])
		m.removedfavourites[ids[i]] = struct{}{}
	}
}

// RemovedFavourites returns the removed IDs of the "favourites" edge to the Favourite entity.
func (m *AgentMutation) RemovedFavouritesIDs() (ids []int) {
	for id := range m.removedfavourites {
		ids = append(ids, id)
	}
	return
}

// FavouritesIDs returns the "favourites" edge IDs in the mutation.
func (m *AgentMutation) FavouritesIDs() (ids []int) {
	for id := range m.favourites {
		ids = append(ids, id)
	}
	return
}

// ResetFavourites resets all changes to the "favourites" edge.
func (m *AgentMutation) ResetFavourites() {
	m.favourites = nil
	m.clearedfavourites = false
	m.removedfavourites = nil
}

// AddStoreIDs adds the "store" edge to the MerchantStore entity by ids.
func (m *AgentMutation) AddStoreIDs(ids ...int) {
	if m.store == nil {
		m.store = make(map[int]struct{})
	}
	for i := range ids {
		m.store[ids[i]] = struct{}{}
	}
}

// ClearStore clears the "store" edge to the MerchantStore entity.
func (m *AgentMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the MerchantStore entity was cleared.
func (m *AgentMutation) StoreCleared() bool {
	return m.clearedstore
}

// RemoveStoreIDs removes the "store" edge to the MerchantStore entity by IDs.
func (m *AgentMutation) RemoveStoreIDs(ids ...int) {
	if m.removedstore == nil {
		m.removedstore = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.store, ids[i])
		m.removedstore[ids[i]] = struct{}{}
	}
}

// RemovedStore returns the removed IDs of the "store" edge to the MerchantStore entity.
func (m *AgentMutation) RemovedStoreIDs() (ids []int) {
	for id := range m.removedstore {
		ids = append(ids, id)
	}
	return
}

// StoreIDs returns the "store" edge IDs in the mutation.
func (m *AgentMutation) StoreIDs() (ids []int) {
	for id := range m.store {
		ids = append(ids, id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *AgentMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
	m.removedstore = nil
}

// AddRequestIDs adds the "requests" edge to the AgentRequest entity by ids.
func (m *AgentMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the AgentRequest entity.
func (m *AgentMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the AgentRequest entity was cleared.
func (m *AgentMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the AgentRequest entity by IDs.
func (m *AgentMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the AgentRequest entity.
func (m *AgentMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *AgentMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *AgentMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, agent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agent.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, agent.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, agent.FieldPassword)
	}
	if m.ghana_card != nil {
		fields = append(fields, agent.FieldGhanaCard)
	}
	if m.last_name != nil {
		fields = append(fields, agent.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, agent.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, agent.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, agent.FieldOtherPhone)
	}
	if m.address != nil {
		fields = append(fields, agent.FieldAddress)
	}
	if m.digital_address != nil {
		fields = append(fields, agent.FieldDigitalAddress)
	}
	if m.region != nil {
		fields = append(fields, agent.FieldRegion)
	}
	if m.district != nil {
		fields = append(fields, agent.FieldDistrict)
	}
	if m.city != nil {
		fields = append(fields, agent.FieldCity)
	}
	if m.default_account != nil {
		fields = append(fields, agent.FieldDefaultAccount)
	}
	if m.bank_account != nil {
		fields = append(fields, agent.FieldBankAccount)
	}
	if m.momo_account != nil {
		fields = append(fields, agent.FieldMomoAccount)
	}
	if m.verified != nil {
		fields = append(fields, agent.FieldVerified)
	}
	if m.compliance != nil {
		fields = append(fields, agent.FieldCompliance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldCreatedAt:
		return m.CreatedAt()
	case agent.FieldUpdatedAt:
		return m.UpdatedAt()
	case agent.FieldUsername:
		return m.Username()
	case agent.FieldPassword:
		return m.Password()
	case agent.FieldGhanaCard:
		return m.GhanaCard()
	case agent.FieldLastName:
		return m.LastName()
	case agent.FieldOtherName:
		return m.OtherName()
	case agent.FieldPhone:
		return m.Phone()
	case agent.FieldOtherPhone:
		return m.OtherPhone()
	case agent.FieldAddress:
		return m.Address()
	case agent.FieldDigitalAddress:
		return m.DigitalAddress()
	case agent.FieldRegion:
		return m.Region()
	case agent.FieldDistrict:
		return m.District()
	case agent.FieldCity:
		return m.City()
	case agent.FieldDefaultAccount:
		return m.DefaultAccount()
	case agent.FieldBankAccount:
		return m.BankAccount()
	case agent.FieldMomoAccount:
		return m.MomoAccount()
	case agent.FieldVerified:
		return m.Verified()
	case agent.FieldCompliance:
		return m.Compliance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case agent.FieldUsername:
		return m.OldUsername(ctx)
	case agent.FieldPassword:
		return m.OldPassword(ctx)
	case agent.FieldGhanaCard:
		return m.OldGhanaCard(ctx)
	case agent.FieldLastName:
		return m.OldLastName(ctx)
	case agent.FieldOtherName:
		return m.OldOtherName(ctx)
	case agent.FieldPhone:
		return m.OldPhone(ctx)
	case agent.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case agent.FieldAddress:
		return m.OldAddress(ctx)
	case agent.FieldDigitalAddress:
		return m.OldDigitalAddress(ctx)
	case agent.FieldRegion:
		return m.OldRegion(ctx)
	case agent.FieldDistrict:
		return m.OldDistrict(ctx)
	case agent.FieldCity:
		return m.OldCity(ctx)
	case agent.FieldDefaultAccount:
		return m.OldDefaultAccount(ctx)
	case agent.FieldBankAccount:
		return m.OldBankAccount(ctx)
	case agent.FieldMomoAccount:
		return m.OldMomoAccount(ctx)
	case agent.FieldVerified:
		return m.OldVerified(ctx)
	case agent.FieldCompliance:
		return m.OldCompliance(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case agent.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case agent.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case agent.FieldGhanaCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGhanaCard(v)
		return nil
	case agent.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case agent.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case agent.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case agent.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case agent.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case agent.FieldDigitalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigitalAddress(v)
		return nil
	case agent.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case agent.FieldDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrict(v)
		return nil
	case agent.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case agent.FieldDefaultAccount:
		v, ok := value.(agent.DefaultAccount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultAccount(v)
		return nil
	case agent.FieldBankAccount:
		v, ok := value.(*models.MerchantBankAccount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccount(v)
		return nil
	case agent.FieldMomoAccount:
		v, ok := value.(*models.MerchantMomoAccount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMomoAccount(v)
		return nil
	case agent.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case agent.FieldCompliance:
		v, ok := value.(*models.AgentComplianceModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompliance(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agent.FieldOtherPhone) {
		fields = append(fields, agent.FieldOtherPhone)
	}
	if m.FieldCleared(agent.FieldRegion) {
		fields = append(fields, agent.FieldRegion)
	}
	if m.FieldCleared(agent.FieldDistrict) {
		fields = append(fields, agent.FieldDistrict)
	}
	if m.FieldCleared(agent.FieldCity) {
		fields = append(fields, agent.FieldCity)
	}
	if m.FieldCleared(agent.FieldDefaultAccount) {
		fields = append(fields, agent.FieldDefaultAccount)
	}
	if m.FieldCleared(agent.FieldBankAccount) {
		fields = append(fields, agent.FieldBankAccount)
	}
	if m.FieldCleared(agent.FieldMomoAccount) {
		fields = append(fields, agent.FieldMomoAccount)
	}
	if m.FieldCleared(agent.FieldCompliance) {
		fields = append(fields, agent.FieldCompliance)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	switch name {
	case agent.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	case agent.FieldRegion:
		m.ClearRegion()
		return nil
	case agent.FieldDistrict:
		m.ClearDistrict()
		return nil
	case agent.FieldCity:
		m.ClearCity()
		return nil
	case agent.FieldDefaultAccount:
		m.ClearDefaultAccount()
		return nil
	case agent.FieldBankAccount:
		m.ClearBankAccount()
		return nil
	case agent.FieldMomoAccount:
		m.ClearMomoAccount()
		return nil
	case agent.FieldCompliance:
		m.ClearCompliance()
		return nil
	}
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case agent.FieldUsername:
		m.ResetUsername()
		return nil
	case agent.FieldPassword:
		m.ResetPassword()
		return nil
	case agent.FieldGhanaCard:
		m.ResetGhanaCard()
		return nil
	case agent.FieldLastName:
		m.ResetLastName()
		return nil
	case agent.FieldOtherName:
		m.ResetOtherName()
		return nil
	case agent.FieldPhone:
		m.ResetPhone()
		return nil
	case agent.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case agent.FieldAddress:
		m.ResetAddress()
		return nil
	case agent.FieldDigitalAddress:
		m.ResetDigitalAddress()
		return nil
	case agent.FieldRegion:
		m.ResetRegion()
		return nil
	case agent.FieldDistrict:
		m.ResetDistrict()
		return nil
	case agent.FieldCity:
		m.ResetCity()
		return nil
	case agent.FieldDefaultAccount:
		m.ResetDefaultAccount()
		return nil
	case agent.FieldBankAccount:
		m.ResetBankAccount()
		return nil
	case agent.FieldMomoAccount:
		m.ResetMomoAccount()
		return nil
	case agent.FieldVerified:
		m.ResetVerified()
		return nil
	case agent.FieldCompliance:
		m.ResetCompliance()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.addresses != nil {
		edges = append(edges, agent.EdgeAddresses)
	}
	if m.orders != nil {
		edges = append(edges, agent.EdgeOrders)
	}
	if m.favourites != nil {
		edges = append(edges, agent.EdgeFavourites)
	}
	if m.store != nil {
		edges = append(edges, agent.EdgeStore)
	}
	if m.requests != nil {
		edges = append(edges, agent.EdgeRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.favourites))
		for id := range m.favourites {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeStore:
		ids := make([]ent.Value, 0, len(m.store))
		for id := range m.store {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedaddresses != nil {
		edges = append(edges, agent.EdgeAddresses)
	}
	if m.removedorders != nil {
		edges = append(edges, agent.EdgeOrders)
	}
	if m.removedfavourites != nil {
		edges = append(edges, agent.EdgeFavourites)
	}
	if m.removedstore != nil {
		edges = append(edges, agent.EdgeStore)
	}
	if m.removedrequests != nil {
		edges = append(edges, agent.EdgeRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.removedfavourites))
		for id := range m.removedfavourites {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeStore:
		ids := make([]ent.Value, 0, len(m.removedstore))
		for id := range m.removedstore {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedaddresses {
		edges = append(edges, agent.EdgeAddresses)
	}
	if m.clearedorders {
		edges = append(edges, agent.EdgeOrders)
	}
	if m.clearedfavourites {
		edges = append(edges, agent.EdgeFavourites)
	}
	if m.clearedstore {
		edges = append(edges, agent.EdgeStore)
	}
	if m.clearedrequests {
		edges = append(edges, agent.EdgeRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeAddresses:
		return m.clearedaddresses
	case agent.EdgeOrders:
		return m.clearedorders
	case agent.EdgeFavourites:
		return m.clearedfavourites
	case agent.EdgeStore:
		return m.clearedstore
	case agent.EdgeRequests:
		return m.clearedrequests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case agent.EdgeOrders:
		m.ResetOrders()
		return nil
	case agent.EdgeFavourites:
		m.ResetFavourites()
		return nil
	case agent.EdgeStore:
		m.ResetStore()
		return nil
	case agent.EdgeRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// AgentRequestMutation represents an operation that mutates the AgentRequest nodes in the graph.
type AgentRequestMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AgentRequest, error)
	predicates    []predicate.AgentRequest
}

var _ ent.Mutation = (*AgentRequestMutation)(nil)

// agentrequestOption allows management of the mutation configuration using functional options.
type agentrequestOption func(*AgentRequestMutation)

// newAgentRequestMutation creates new mutation for the AgentRequest entity.
func newAgentRequestMutation(c config, op Op, opts ...agentrequestOption) *AgentRequestMutation {
	m := &AgentRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentRequestID sets the ID field of the mutation.
func withAgentRequestID(id int) agentrequestOption {
	return func(m *AgentRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentRequest
		)
		m.oldValue = func(ctx context.Context) (*AgentRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentRequest sets the old AgentRequest of the mutation.
func withAgentRequest(node *AgentRequest) agentrequestOption {
	return func(m *AgentRequestMutation) {
		m.oldValue = func(context.Context) (*AgentRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AgentRequest entity.
// If the AgentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AgentRequest entity.
// If the AgentRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the AgentRequestMutation builder.
func (m *AgentRequestMutation) Where(ps ...predicate.AgentRequest) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AgentRequestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AgentRequest).
func (m *AgentRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentRequestMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, agentrequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agentrequest.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agentrequest.FieldCreatedAt:
		return m.CreatedAt()
	case agentrequest.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agentrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agentrequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AgentRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agentrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agentrequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AgentRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AgentRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AgentRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentRequestMutation) ResetField(name string) error {
	switch name {
	case agentrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agentrequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AgentRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentRequestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentRequestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentRequestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AgentRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentRequestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AgentRequest edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	username          *string
	password          *[]byte
	first_name        *string
	last_name         *string
	phone             *string
	other_phone       *string
	clearedFields     map[string]struct{}
	addresses         map[int]struct{}
	removedaddresses  map[int]struct{}
	clearedaddresses  bool
	orders            map[int]struct{}
	removedorders     map[int]struct{}
	clearedorders     bool
	favourites        map[int]struct{}
	removedfavourites map[int]struct{}
	clearedfavourites bool
	done              bool
	oldValue          func(context.Context) (*Customer, error)
	predicates        []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *CustomerMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *CustomerMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *CustomerMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *CustomerMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *CustomerMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *CustomerMutation) ResetPassword() {
	m.password = nil
}

// SetFirstName sets the "first_name" field.
func (m *CustomerMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *CustomerMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *CustomerMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *CustomerMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *CustomerMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *CustomerMutation) ResetLastName() {
	m.last_name = nil
}

// SetPhone sets the "phone" field.
func (m *CustomerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CustomerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CustomerMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *CustomerMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *CustomerMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldOtherPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *CustomerMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[customer.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *CustomerMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[customer.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *CustomerMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, customer.FieldOtherPhone)
}

// AddAddressIDs adds the "addresses" edge to the Address entity by ids.
func (m *CustomerMutation) AddAddressIDs(ids ...int) {
	if m.addresses == nil {
		m.addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *CustomerMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *CustomerMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the Address entity by IDs.
func (m *CustomerMutation) RemoveAddressIDs(ids ...int) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the Address entity.
func (m *CustomerMutation) RemovedAddressesIDs() (ids []int) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *CustomerMutation) AddressesIDs() (ids []int) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *CustomerMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *CustomerMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *CustomerMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *CustomerMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *CustomerMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *CustomerMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *CustomerMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *CustomerMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddFavouriteIDs adds the "favourites" edge to the Favourite entity by ids.
func (m *CustomerMutation) AddFavouriteIDs(ids ...int) {
	if m.favourites == nil {
		m.favourites = make(map[int]struct{})
	}
	for i := range ids {
		m.favourites[ids[i]] = struct{}{}
	}
}

// ClearFavourites clears the "favourites" edge to the Favourite entity.
func (m *CustomerMutation) ClearFavourites() {
	m.clearedfavourites = true
}

// FavouritesCleared reports if the "favourites" edge to the Favourite entity was cleared.
func (m *CustomerMutation) FavouritesCleared() bool {
	return m.clearedfavourites
}

// RemoveFavouriteIDs removes the "favourites" edge to the Favourite entity by IDs.
func (m *CustomerMutation) RemoveFavouriteIDs(ids ...int) {
	if m.removedfavourites == nil {
		m.removedfavourites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favourites, ids[i])
		m.removedfavourites[ids[i]] = struct{}{}
	}
}

// RemovedFavourites returns the removed IDs of the "favourites" edge to the Favourite entity.
func (m *CustomerMutation) RemovedFavouritesIDs() (ids []int) {
	for id := range m.removedfavourites {
		ids = append(ids, id)
	}
	return
}

// FavouritesIDs returns the "favourites" edge IDs in the mutation.
func (m *CustomerMutation) FavouritesIDs() (ids []int) {
	for id := range m.favourites {
		ids = append(ids, id)
	}
	return
}

// ResetFavourites resets all changes to the "favourites" edge.
func (m *CustomerMutation) ResetFavourites() {
	m.favourites = nil
	m.clearedfavourites = false
	m.removedfavourites = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, customer.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, customer.FieldPassword)
	}
	if m.first_name != nil {
		fields = append(fields, customer.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, customer.FieldLastName)
	}
	if m.phone != nil {
		fields = append(fields, customer.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, customer.FieldOtherPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldUsername:
		return m.Username()
	case customer.FieldPassword:
		return m.Password()
	case customer.FieldFirstName:
		return m.FirstName()
	case customer.FieldLastName:
		return m.LastName()
	case customer.FieldPhone:
		return m.Phone()
	case customer.FieldOtherPhone:
		return m.OtherPhone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldUsername:
		return m.OldUsername(ctx)
	case customer.FieldPassword:
		return m.OldPassword(ctx)
	case customer.FieldFirstName:
		return m.OldFirstName(ctx)
	case customer.FieldLastName:
		return m.OldLastName(ctx)
	case customer.FieldPhone:
		return m.OldPhone(ctx)
	case customer.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case customer.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case customer.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case customer.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case customer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case customer.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldOtherPhone) {
		fields = append(fields, customer.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldUsername:
		m.ResetUsername()
		return nil
	case customer.FieldPassword:
		m.ResetPassword()
		return nil
	case customer.FieldFirstName:
		m.ResetFirstName()
		return nil
	case customer.FieldLastName:
		m.ResetLastName()
		return nil
	case customer.FieldPhone:
		m.ResetPhone()
		return nil
	case customer.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.addresses != nil {
		edges = append(edges, customer.EdgeAddresses)
	}
	if m.orders != nil {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.favourites != nil {
		edges = append(edges, customer.EdgeFavourites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.favourites))
		for id := range m.favourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedaddresses != nil {
		edges = append(edges, customer.EdgeAddresses)
	}
	if m.removedorders != nil {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.removedfavourites != nil {
		edges = append(edges, customer.EdgeFavourites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.removedfavourites))
		for id := range m.removedfavourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedaddresses {
		edges = append(edges, customer.EdgeAddresses)
	}
	if m.clearedorders {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.clearedfavourites {
		edges = append(edges, customer.EdgeFavourites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeAddresses:
		return m.clearedaddresses
	case customer.EdgeOrders:
		return m.clearedorders
	case customer.EdgeFavourites:
		return m.clearedfavourites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case customer.EdgeOrders:
		m.ResetOrders()
		return nil
	case customer.EdgeFavourites:
		m.ResetFavourites()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// FavouriteMutation represents an operation that mutates the Favourite nodes in the graph.
type FavouriteMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	merchant        *int
	clearedmerchant bool
	agent           *int
	clearedagent    bool
	customer        *int
	clearedcustomer bool
	product         *int
	clearedproduct  bool
	done            bool
	oldValue        func(context.Context) (*Favourite, error)
	predicates      []predicate.Favourite
}

var _ ent.Mutation = (*FavouriteMutation)(nil)

// favouriteOption allows management of the mutation configuration using functional options.
type favouriteOption func(*FavouriteMutation)

// newFavouriteMutation creates new mutation for the Favourite entity.
func newFavouriteMutation(c config, op Op, opts ...favouriteOption) *FavouriteMutation {
	m := &FavouriteMutation{
		config:        c,
		op:            op,
		typ:           TypeFavourite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFavouriteID sets the ID field of the mutation.
func withFavouriteID(id int) favouriteOption {
	return func(m *FavouriteMutation) {
		var (
			err   error
			once  sync.Once
			value *Favourite
		)
		m.oldValue = func(ctx context.Context) (*Favourite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Favourite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFavourite sets the old Favourite of the mutation.
func withFavourite(node *Favourite) favouriteOption {
	return func(m *FavouriteMutation) {
		m.oldValue = func(context.Context) (*Favourite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FavouriteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FavouriteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FavouriteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FavouriteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Favourite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FavouriteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FavouriteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Favourite entity.
// If the Favourite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavouriteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FavouriteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FavouriteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FavouriteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Favourite entity.
// If the Favourite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavouriteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FavouriteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *FavouriteMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *FavouriteMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *FavouriteMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *FavouriteMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *FavouriteMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *FavouriteMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *FavouriteMutation) SetAgentID(id int) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *FavouriteMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *FavouriteMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *FavouriteMutation) AgentID() (id int, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *FavouriteMutation) AgentIDs() (ids []int) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *FavouriteMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *FavouriteMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *FavouriteMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *FavouriteMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *FavouriteMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *FavouriteMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *FavouriteMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *FavouriteMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *FavouriteMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *FavouriteMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *FavouriteMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *FavouriteMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *FavouriteMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the FavouriteMutation builder.
func (m *FavouriteMutation) Where(ps ...predicate.Favourite) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FavouriteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Favourite).
func (m *FavouriteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FavouriteMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, favourite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, favourite.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FavouriteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case favourite.FieldCreatedAt:
		return m.CreatedAt()
	case favourite.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FavouriteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case favourite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case favourite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Favourite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavouriteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case favourite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case favourite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Favourite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FavouriteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FavouriteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavouriteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Favourite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FavouriteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FavouriteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FavouriteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Favourite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FavouriteMutation) ResetField(name string) error {
	switch name {
	case favourite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case favourite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Favourite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FavouriteMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.merchant != nil {
		edges = append(edges, favourite.EdgeMerchant)
	}
	if m.agent != nil {
		edges = append(edges, favourite.EdgeAgent)
	}
	if m.customer != nil {
		edges = append(edges, favourite.EdgeCustomer)
	}
	if m.product != nil {
		edges = append(edges, favourite.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FavouriteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case favourite.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case favourite.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case favourite.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case favourite.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FavouriteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FavouriteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FavouriteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmerchant {
		edges = append(edges, favourite.EdgeMerchant)
	}
	if m.clearedagent {
		edges = append(edges, favourite.EdgeAgent)
	}
	if m.clearedcustomer {
		edges = append(edges, favourite.EdgeCustomer)
	}
	if m.clearedproduct {
		edges = append(edges, favourite.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FavouriteMutation) EdgeCleared(name string) bool {
	switch name {
	case favourite.EdgeMerchant:
		return m.clearedmerchant
	case favourite.EdgeAgent:
		return m.clearedagent
	case favourite.EdgeCustomer:
		return m.clearedcustomer
	case favourite.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FavouriteMutation) ClearEdge(name string) error {
	switch name {
	case favourite.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case favourite.EdgeAgent:
		m.ClearAgent()
		return nil
	case favourite.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case favourite.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Favourite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FavouriteMutation) ResetEdge(name string) error {
	switch name {
	case favourite.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case favourite.EdgeAgent:
		m.ResetAgent()
		return nil
	case favourite.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case favourite.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Favourite edge %s", name)
}

// MerchantMutation represents an operation that mutates the Merchant nodes in the graph.
type MerchantMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	username          *string
	password          *[]byte
	_type             *string
	otp               *merchant.Otp
	clearedFields     map[string]struct{}
	supplier          *int
	clearedsupplier   bool
	retailer          *int
	clearedretailer   bool
	store             *int
	clearedstore      bool
	products          map[int]struct{}
	removedproducts   map[int]struct{}
	clearedproducts   bool
	addresses         map[int]struct{}
	removedaddresses  map[int]struct{}
	clearedaddresses  bool
	orders            map[int]struct{}
	removedorders     map[int]struct{}
	clearedorders     bool
	favourites        map[int]struct{}
	removedfavourites map[int]struct{}
	clearedfavourites bool
	done              bool
	oldValue          func(context.Context) (*Merchant, error)
	predicates        []predicate.Merchant
}

var _ ent.Mutation = (*MerchantMutation)(nil)

// merchantOption allows management of the mutation configuration using functional options.
type merchantOption func(*MerchantMutation)

// newMerchantMutation creates new mutation for the Merchant entity.
func newMerchantMutation(c config, op Op, opts ...merchantOption) *MerchantMutation {
	m := &MerchantMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantID sets the ID field of the mutation.
func withMerchantID(id int) merchantOption {
	return func(m *MerchantMutation) {
		var (
			err   error
			once  sync.Once
			value *Merchant
		)
		m.oldValue = func(ctx context.Context) (*Merchant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Merchant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchant sets the old Merchant of the mutation.
func withMerchant(node *Merchant) merchantOption {
	return func(m *MerchantMutation) {
		m.oldValue = func(context.Context) (*Merchant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MerchantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MerchantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Merchant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MerchantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MerchantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MerchantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MerchantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MerchantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MerchantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *MerchantMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *MerchantMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *MerchantMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *MerchantMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *MerchantMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *MerchantMutation) ResetPassword() {
	m.password = nil
}

// SetType sets the "type" field.
func (m *MerchantMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MerchantMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MerchantMutation) ResetType() {
	m._type = nil
}

// SetOtp sets the "otp" field.
func (m *MerchantMutation) SetOtp(value merchant.Otp) {
	m.otp = &value
}

// Otp returns the value of the "otp" field in the mutation.
func (m *MerchantMutation) Otp() (r merchant.Otp, exists bool) {
	v := m.otp
	if v == nil {
		return
	}
	return *v, true
}

// OldOtp returns the old "otp" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldOtp(ctx context.Context) (v merchant.Otp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtp: %w", err)
	}
	return oldValue.Otp, nil
}

// ClearOtp clears the value of the "otp" field.
func (m *MerchantMutation) ClearOtp() {
	m.otp = nil
	m.clearedFields[merchant.FieldOtp] = struct{}{}
}

// OtpCleared returns if the "otp" field was cleared in this mutation.
func (m *MerchantMutation) OtpCleared() bool {
	_, ok := m.clearedFields[merchant.FieldOtp]
	return ok
}

// ResetOtp resets all changes to the "otp" field.
func (m *MerchantMutation) ResetOtp() {
	m.otp = nil
	delete(m.clearedFields, merchant.FieldOtp)
}

// SetSupplierID sets the "supplier" edge to the SupplierMerchant entity by id.
func (m *MerchantMutation) SetSupplierID(id int) {
	m.supplier = &id
}

// ClearSupplier clears the "supplier" edge to the SupplierMerchant entity.
func (m *MerchantMutation) ClearSupplier() {
	m.clearedsupplier = true
}

// SupplierCleared reports if the "supplier" edge to the SupplierMerchant entity was cleared.
func (m *MerchantMutation) SupplierCleared() bool {
	return m.clearedsupplier
}

// SupplierID returns the "supplier" edge ID in the mutation.
func (m *MerchantMutation) SupplierID() (id int, exists bool) {
	if m.supplier != nil {
		return *m.supplier, true
	}
	return
}

// SupplierIDs returns the "supplier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupplierID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) SupplierIDs() (ids []int) {
	if id := m.supplier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupplier resets all changes to the "supplier" edge.
func (m *MerchantMutation) ResetSupplier() {
	m.supplier = nil
	m.clearedsupplier = false
}

// SetRetailerID sets the "retailer" edge to the RetailMerchant entity by id.
func (m *MerchantMutation) SetRetailerID(id int) {
	m.retailer = &id
}

// ClearRetailer clears the "retailer" edge to the RetailMerchant entity.
func (m *MerchantMutation) ClearRetailer() {
	m.clearedretailer = true
}

// RetailerCleared reports if the "retailer" edge to the RetailMerchant entity was cleared.
func (m *MerchantMutation) RetailerCleared() bool {
	return m.clearedretailer
}

// RetailerID returns the "retailer" edge ID in the mutation.
func (m *MerchantMutation) RetailerID() (id int, exists bool) {
	if m.retailer != nil {
		return *m.retailer, true
	}
	return
}

// RetailerIDs returns the "retailer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetailerID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) RetailerIDs() (ids []int) {
	if id := m.retailer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetailer resets all changes to the "retailer" edge.
func (m *MerchantMutation) ResetRetailer() {
	m.retailer = nil
	m.clearedretailer = false
}

// SetStoreID sets the "store" edge to the MerchantStore entity by id.
func (m *MerchantMutation) SetStoreID(id int) {
	m.store = &id
}

// ClearStore clears the "store" edge to the MerchantStore entity.
func (m *MerchantMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the MerchantStore entity was cleared.
func (m *MerchantMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreID returns the "store" edge ID in the mutation.
func (m *MerchantMutation) StoreID() (id int, exists bool) {
	if m.store != nil {
		return *m.store, true
	}
	return
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) StoreIDs() (ids []int) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *MerchantMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *MerchantMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *MerchantMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *MerchantMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *MerchantMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *MerchantMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *MerchantMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *MerchantMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddAddressIDs adds the "addresses" edge to the Address entity by ids.
func (m *MerchantMutation) AddAddressIDs(ids ...int) {
	if m.addresses == nil {
		m.addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *MerchantMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *MerchantMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the Address entity by IDs.
func (m *MerchantMutation) RemoveAddressIDs(ids ...int) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the Address entity.
func (m *MerchantMutation) RemovedAddressesIDs() (ids []int) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *MerchantMutation) AddressesIDs() (ids []int) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *MerchantMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *MerchantMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *MerchantMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *MerchantMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *MerchantMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *MerchantMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *MerchantMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *MerchantMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddFavouriteIDs adds the "favourites" edge to the Favourite entity by ids.
func (m *MerchantMutation) AddFavouriteIDs(ids ...int) {
	if m.favourites == nil {
		m.favourites = make(map[int]struct{})
	}
	for i := range ids {
		m.favourites[ids[i]] = struct{}{}
	}
}

// ClearFavourites clears the "favourites" edge to the Favourite entity.
func (m *MerchantMutation) ClearFavourites() {
	m.clearedfavourites = true
}

// FavouritesCleared reports if the "favourites" edge to the Favourite entity was cleared.
func (m *MerchantMutation) FavouritesCleared() bool {
	return m.clearedfavourites
}

// RemoveFavouriteIDs removes the "favourites" edge to the Favourite entity by IDs.
func (m *MerchantMutation) RemoveFavouriteIDs(ids ...int) {
	if m.removedfavourites == nil {
		m.removedfavourites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favourites, ids[i])
		m.removedfavourites[ids[i]] = struct{}{}
	}
}

// RemovedFavourites returns the removed IDs of the "favourites" edge to the Favourite entity.
func (m *MerchantMutation) RemovedFavouritesIDs() (ids []int) {
	for id := range m.removedfavourites {
		ids = append(ids, id)
	}
	return
}

// FavouritesIDs returns the "favourites" edge IDs in the mutation.
func (m *MerchantMutation) FavouritesIDs() (ids []int) {
	for id := range m.favourites {
		ids = append(ids, id)
	}
	return
}

// ResetFavourites resets all changes to the "favourites" edge.
func (m *MerchantMutation) ResetFavourites() {
	m.favourites = nil
	m.clearedfavourites = false
	m.removedfavourites = nil
}

// Where appends a list predicates to the MerchantMutation builder.
func (m *MerchantMutation) Where(ps ...predicate.Merchant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MerchantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Merchant).
func (m *MerchantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, merchant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, merchant.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, merchant.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, merchant.FieldPassword)
	}
	if m._type != nil {
		fields = append(fields, merchant.FieldType)
	}
	if m.otp != nil {
		fields = append(fields, merchant.FieldOtp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchant.FieldCreatedAt:
		return m.CreatedAt()
	case merchant.FieldUpdatedAt:
		return m.UpdatedAt()
	case merchant.FieldUsername:
		return m.Username()
	case merchant.FieldPassword:
		return m.Password()
	case merchant.FieldType:
		return m.GetType()
	case merchant.FieldOtp:
		return m.Otp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case merchant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case merchant.FieldUsername:
		return m.OldUsername(ctx)
	case merchant.FieldPassword:
		return m.OldPassword(ctx)
	case merchant.FieldType:
		return m.OldType(ctx)
	case merchant.FieldOtp:
		return m.OldOtp(ctx)
	}
	return nil, fmt.Errorf("unknown Merchant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case merchant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case merchant.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case merchant.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case merchant.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case merchant.FieldOtp:
		v, ok := value.(merchant.Otp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtp(v)
		return nil
	}
	return fmt.Errorf("unknown Merchant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Merchant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(merchant.FieldOtp) {
		fields = append(fields, merchant.FieldOtp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantMutation) ClearField(name string) error {
	switch name {
	case merchant.FieldOtp:
		m.ClearOtp()
		return nil
	}
	return fmt.Errorf("unknown Merchant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantMutation) ResetField(name string) error {
	switch name {
	case merchant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case merchant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case merchant.FieldUsername:
		m.ResetUsername()
		return nil
	case merchant.FieldPassword:
		m.ResetPassword()
		return nil
	case merchant.FieldType:
		m.ResetType()
		return nil
	case merchant.FieldOtp:
		m.ResetOtp()
		return nil
	}
	return fmt.Errorf("unknown Merchant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.supplier != nil {
		edges = append(edges, merchant.EdgeSupplier)
	}
	if m.retailer != nil {
		edges = append(edges, merchant.EdgeRetailer)
	}
	if m.store != nil {
		edges = append(edges, merchant.EdgeStore)
	}
	if m.products != nil {
		edges = append(edges, merchant.EdgeProducts)
	}
	if m.addresses != nil {
		edges = append(edges, merchant.EdgeAddresses)
	}
	if m.orders != nil {
		edges = append(edges, merchant.EdgeOrders)
	}
	if m.favourites != nil {
		edges = append(edges, merchant.EdgeFavourites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case merchant.EdgeSupplier:
		if id := m.supplier; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeRetailer:
		if id := m.retailer; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.favourites))
		for id := range m.favourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedproducts != nil {
		edges = append(edges, merchant.EdgeProducts)
	}
	if m.removedaddresses != nil {
		edges = append(edges, merchant.EdgeAddresses)
	}
	if m.removedorders != nil {
		edges = append(edges, merchant.EdgeOrders)
	}
	if m.removedfavourites != nil {
		edges = append(edges, merchant.EdgeFavourites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case merchant.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.removedfavourites))
		for id := range m.removedfavourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedsupplier {
		edges = append(edges, merchant.EdgeSupplier)
	}
	if m.clearedretailer {
		edges = append(edges, merchant.EdgeRetailer)
	}
	if m.clearedstore {
		edges = append(edges, merchant.EdgeStore)
	}
	if m.clearedproducts {
		edges = append(edges, merchant.EdgeProducts)
	}
	if m.clearedaddresses {
		edges = append(edges, merchant.EdgeAddresses)
	}
	if m.clearedorders {
		edges = append(edges, merchant.EdgeOrders)
	}
	if m.clearedfavourites {
		edges = append(edges, merchant.EdgeFavourites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantMutation) EdgeCleared(name string) bool {
	switch name {
	case merchant.EdgeSupplier:
		return m.clearedsupplier
	case merchant.EdgeRetailer:
		return m.clearedretailer
	case merchant.EdgeStore:
		return m.clearedstore
	case merchant.EdgeProducts:
		return m.clearedproducts
	case merchant.EdgeAddresses:
		return m.clearedaddresses
	case merchant.EdgeOrders:
		return m.clearedorders
	case merchant.EdgeFavourites:
		return m.clearedfavourites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantMutation) ClearEdge(name string) error {
	switch name {
	case merchant.EdgeSupplier:
		m.ClearSupplier()
		return nil
	case merchant.EdgeRetailer:
		m.ClearRetailer()
		return nil
	case merchant.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Merchant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantMutation) ResetEdge(name string) error {
	switch name {
	case merchant.EdgeSupplier:
		m.ResetSupplier()
		return nil
	case merchant.EdgeRetailer:
		m.ResetRetailer()
		return nil
	case merchant.EdgeStore:
		m.ResetStore()
		return nil
	case merchant.EdgeProducts:
		m.ResetProducts()
		return nil
	case merchant.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case merchant.EdgeOrders:
		m.ResetOrders()
		return nil
	case merchant.EdgeFavourites:
		m.ResetFavourites()
		return nil
	}
	return fmt.Errorf("unknown Merchant edge %s", name)
}

// MerchantStoreMutation represents an operation that mutates the MerchantStore nodes in the graph.
type MerchantStoreMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	about                *string
	desc_title           *string
	description          *string
	logo                 *string
	images               *[]string
	region               *string
	district             *string
	city                 *string
	default_account      *merchantstore.DefaultAccount
	bank_account         **models.MerchantBankAccount
	momo_account         **models.MerchantMomoAccount
	merchant_type        *string
	permit_agent         *bool
	clearedFields        map[string]struct{}
	merchant             *int
	clearedmerchant      bool
	agent                *int
	clearedagent         bool
	requests             map[int]struct{}
	removedrequests      map[int]struct{}
	clearedrequests      bool
	orders               map[int]struct{}
	removedorders        map[int]struct{}
	clearedorders        bool
	order_details        map[int]struct{}
	removedorder_details map[int]struct{}
	clearedorder_details bool
	done                 bool
	oldValue             func(context.Context) (*MerchantStore, error)
	predicates           []predicate.MerchantStore
}

var _ ent.Mutation = (*MerchantStoreMutation)(nil)

// merchantstoreOption allows management of the mutation configuration using functional options.
type merchantstoreOption func(*MerchantStoreMutation)

// newMerchantStoreMutation creates new mutation for the MerchantStore entity.
func newMerchantStoreMutation(c config, op Op, opts ...merchantstoreOption) *MerchantStoreMutation {
	m := &MerchantStoreMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchantStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantStoreID sets the ID field of the mutation.
func withMerchantStoreID(id int) merchantstoreOption {
	return func(m *MerchantStoreMutation) {
		var (
			err   error
			once  sync.Once
			value *MerchantStore
		)
		m.oldValue = func(ctx context.Context) (*MerchantStore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MerchantStore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchantStore sets the old MerchantStore of the mutation.
func withMerchantStore(node *MerchantStore) merchantstoreOption {
	return func(m *MerchantStoreMutation) {
		m.oldValue = func(context.Context) (*MerchantStore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantStoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantStoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MerchantStoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MerchantStoreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MerchantStore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MerchantStoreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MerchantStoreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MerchantStoreMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MerchantStoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MerchantStoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MerchantStoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *MerchantStoreMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MerchantStoreMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MerchantStoreMutation) ResetName() {
	m.name = nil
}

// SetAbout sets the "about" field.
func (m *MerchantStoreMutation) SetAbout(s string) {
	m.about = &s
}

// About returns the value of the "about" field in the mutation.
func (m *MerchantStoreMutation) About() (r string, exists bool) {
	v := m.about
	if v == nil {
		return
	}
	return *v, true
}

// OldAbout returns the old "about" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldAbout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbout: %w", err)
	}
	return oldValue.About, nil
}

// ResetAbout resets all changes to the "about" field.
func (m *MerchantStoreMutation) ResetAbout() {
	m.about = nil
}

// SetDescTitle sets the "desc_title" field.
func (m *MerchantStoreMutation) SetDescTitle(s string) {
	m.desc_title = &s
}

// DescTitle returns the value of the "desc_title" field in the mutation.
func (m *MerchantStoreMutation) DescTitle() (r string, exists bool) {
	v := m.desc_title
	if v == nil {
		return
	}
	return *v, true
}

// OldDescTitle returns the old "desc_title" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldDescTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescTitle: %w", err)
	}
	return oldValue.DescTitle, nil
}

// ResetDescTitle resets all changes to the "desc_title" field.
func (m *MerchantStoreMutation) ResetDescTitle() {
	m.desc_title = nil
}

// SetDescription sets the "description" field.
func (m *MerchantStoreMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MerchantStoreMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *MerchantStoreMutation) ResetDescription() {
	m.description = nil
}

// SetLogo sets the "logo" field.
func (m *MerchantStoreMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *MerchantStoreMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *MerchantStoreMutation) ResetLogo() {
	m.logo = nil
}

// SetImages sets the "images" field.
func (m *MerchantStoreMutation) SetImages(s []string) {
	m.images = &s
}

// Images returns the value of the "images" field in the mutation.
func (m *MerchantStoreMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ClearImages clears the value of the "images" field.
func (m *MerchantStoreMutation) ClearImages() {
	m.images = nil
	m.clearedFields[merchantstore.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *MerchantStoreMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *MerchantStoreMutation) ResetImages() {
	m.images = nil
	delete(m.clearedFields, merchantstore.FieldImages)
}

// SetRegion sets the "region" field.
func (m *MerchantStoreMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *MerchantStoreMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldRegion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ClearRegion clears the value of the "region" field.
func (m *MerchantStoreMutation) ClearRegion() {
	m.region = nil
	m.clearedFields[merchantstore.FieldRegion] = struct{}{}
}

// RegionCleared returns if the "region" field was cleared in this mutation.
func (m *MerchantStoreMutation) RegionCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldRegion]
	return ok
}

// ResetRegion resets all changes to the "region" field.
func (m *MerchantStoreMutation) ResetRegion() {
	m.region = nil
	delete(m.clearedFields, merchantstore.FieldRegion)
}

// SetDistrict sets the "district" field.
func (m *MerchantStoreMutation) SetDistrict(s string) {
	m.district = &s
}

// District returns the value of the "district" field in the mutation.
func (m *MerchantStoreMutation) District() (r string, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrict returns the old "district" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldDistrict(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrict: %w", err)
	}
	return oldValue.District, nil
}

// ClearDistrict clears the value of the "district" field.
func (m *MerchantStoreMutation) ClearDistrict() {
	m.district = nil
	m.clearedFields[merchantstore.FieldDistrict] = struct{}{}
}

// DistrictCleared returns if the "district" field was cleared in this mutation.
func (m *MerchantStoreMutation) DistrictCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldDistrict]
	return ok
}

// ResetDistrict resets all changes to the "district" field.
func (m *MerchantStoreMutation) ResetDistrict() {
	m.district = nil
	delete(m.clearedFields, merchantstore.FieldDistrict)
}

// SetCity sets the "city" field.
func (m *MerchantStoreMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *MerchantStoreMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *MerchantStoreMutation) ClearCity() {
	m.city = nil
	m.clearedFields[merchantstore.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *MerchantStoreMutation) CityCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *MerchantStoreMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, merchantstore.FieldCity)
}

// SetDefaultAccount sets the "default_account" field.
func (m *MerchantStoreMutation) SetDefaultAccount(ma merchantstore.DefaultAccount) {
	m.default_account = &ma
}

// DefaultAccount returns the value of the "default_account" field in the mutation.
func (m *MerchantStoreMutation) DefaultAccount() (r merchantstore.DefaultAccount, exists bool) {
	v := m.default_account
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultAccount returns the old "default_account" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldDefaultAccount(ctx context.Context) (v merchantstore.DefaultAccount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultAccount: %w", err)
	}
	return oldValue.DefaultAccount, nil
}

// ClearDefaultAccount clears the value of the "default_account" field.
func (m *MerchantStoreMutation) ClearDefaultAccount() {
	m.default_account = nil
	m.clearedFields[merchantstore.FieldDefaultAccount] = struct{}{}
}

// DefaultAccountCleared returns if the "default_account" field was cleared in this mutation.
func (m *MerchantStoreMutation) DefaultAccountCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldDefaultAccount]
	return ok
}

// ResetDefaultAccount resets all changes to the "default_account" field.
func (m *MerchantStoreMutation) ResetDefaultAccount() {
	m.default_account = nil
	delete(m.clearedFields, merchantstore.FieldDefaultAccount)
}

// SetBankAccount sets the "bank_account" field.
func (m *MerchantStoreMutation) SetBankAccount(mba *models.MerchantBankAccount) {
	m.bank_account = &mba
}

// BankAccount returns the value of the "bank_account" field in the mutation.
func (m *MerchantStoreMutation) BankAccount() (r *models.MerchantBankAccount, exists bool) {
	v := m.bank_account
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccount returns the old "bank_account" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldBankAccount(ctx context.Context) (v *models.MerchantBankAccount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccount: %w", err)
	}
	return oldValue.BankAccount, nil
}

// ClearBankAccount clears the value of the "bank_account" field.
func (m *MerchantStoreMutation) ClearBankAccount() {
	m.bank_account = nil
	m.clearedFields[merchantstore.FieldBankAccount] = struct{}{}
}

// BankAccountCleared returns if the "bank_account" field was cleared in this mutation.
func (m *MerchantStoreMutation) BankAccountCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldBankAccount]
	return ok
}

// ResetBankAccount resets all changes to the "bank_account" field.
func (m *MerchantStoreMutation) ResetBankAccount() {
	m.bank_account = nil
	delete(m.clearedFields, merchantstore.FieldBankAccount)
}

// SetMomoAccount sets the "momo_account" field.
func (m *MerchantStoreMutation) SetMomoAccount(mma *models.MerchantMomoAccount) {
	m.momo_account = &mma
}

// MomoAccount returns the value of the "momo_account" field in the mutation.
func (m *MerchantStoreMutation) MomoAccount() (r *models.MerchantMomoAccount, exists bool) {
	v := m.momo_account
	if v == nil {
		return
	}
	return *v, true
}

// OldMomoAccount returns the old "momo_account" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldMomoAccount(ctx context.Context) (v *models.MerchantMomoAccount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMomoAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMomoAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMomoAccount: %w", err)
	}
	return oldValue.MomoAccount, nil
}

// ClearMomoAccount clears the value of the "momo_account" field.
func (m *MerchantStoreMutation) ClearMomoAccount() {
	m.momo_account = nil
	m.clearedFields[merchantstore.FieldMomoAccount] = struct{}{}
}

// MomoAccountCleared returns if the "momo_account" field was cleared in this mutation.
func (m *MerchantStoreMutation) MomoAccountCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldMomoAccount]
	return ok
}

// ResetMomoAccount resets all changes to the "momo_account" field.
func (m *MerchantStoreMutation) ResetMomoAccount() {
	m.momo_account = nil
	delete(m.clearedFields, merchantstore.FieldMomoAccount)
}

// SetMerchantType sets the "merchant_type" field.
func (m *MerchantStoreMutation) SetMerchantType(s string) {
	m.merchant_type = &s
}

// MerchantType returns the value of the "merchant_type" field in the mutation.
func (m *MerchantStoreMutation) MerchantType() (r string, exists bool) {
	v := m.merchant_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantType returns the old "merchant_type" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldMerchantType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantType: %w", err)
	}
	return oldValue.MerchantType, nil
}

// ResetMerchantType resets all changes to the "merchant_type" field.
func (m *MerchantStoreMutation) ResetMerchantType() {
	m.merchant_type = nil
}

// SetPermitAgent sets the "permit_agent" field.
func (m *MerchantStoreMutation) SetPermitAgent(b bool) {
	m.permit_agent = &b
}

// PermitAgent returns the value of the "permit_agent" field in the mutation.
func (m *MerchantStoreMutation) PermitAgent() (r bool, exists bool) {
	v := m.permit_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldPermitAgent returns the old "permit_agent" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldPermitAgent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermitAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermitAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermitAgent: %w", err)
	}
	return oldValue.PermitAgent, nil
}

// ResetPermitAgent resets all changes to the "permit_agent" field.
func (m *MerchantStoreMutation) ResetPermitAgent() {
	m.permit_agent = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *MerchantStoreMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *MerchantStoreMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *MerchantStoreMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *MerchantStoreMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *MerchantStoreMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *MerchantStoreMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *MerchantStoreMutation) SetAgentID(id int) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *MerchantStoreMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *MerchantStoreMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *MerchantStoreMutation) AgentID() (id int, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *MerchantStoreMutation) AgentIDs() (ids []int) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *MerchantStoreMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// AddRequestIDs adds the "requests" edge to the AgentRequest entity by ids.
func (m *MerchantStoreMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the AgentRequest entity.
func (m *MerchantStoreMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the AgentRequest entity was cleared.
func (m *MerchantStoreMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the AgentRequest entity by IDs.
func (m *MerchantStoreMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the AgentRequest entity.
func (m *MerchantStoreMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *MerchantStoreMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *MerchantStoreMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *MerchantStoreMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *MerchantStoreMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *MerchantStoreMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *MerchantStoreMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *MerchantStoreMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *MerchantStoreMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *MerchantStoreMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddOrderDetailIDs adds the "order_details" edge to the OrderDetail entity by ids.
func (m *MerchantStoreMutation) AddOrderDetailIDs(ids ...int) {
	if m.order_details == nil {
		m.order_details = make(map[int]struct{})
	}
	for i := range ids {
		m.order_details[ids[i]] = struct{}{}
	}
}

// ClearOrderDetails clears the "order_details" edge to the OrderDetail entity.
func (m *MerchantStoreMutation) ClearOrderDetails() {
	m.clearedorder_details = true
}

// OrderDetailsCleared reports if the "order_details" edge to the OrderDetail entity was cleared.
func (m *MerchantStoreMutation) OrderDetailsCleared() bool {
	return m.clearedorder_details
}

// RemoveOrderDetailIDs removes the "order_details" edge to the OrderDetail entity by IDs.
func (m *MerchantStoreMutation) RemoveOrderDetailIDs(ids ...int) {
	if m.removedorder_details == nil {
		m.removedorder_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_details, ids[i])
		m.removedorder_details[ids[i]] = struct{}{}
	}
}

// RemovedOrderDetails returns the removed IDs of the "order_details" edge to the OrderDetail entity.
func (m *MerchantStoreMutation) RemovedOrderDetailsIDs() (ids []int) {
	for id := range m.removedorder_details {
		ids = append(ids, id)
	}
	return
}

// OrderDetailsIDs returns the "order_details" edge IDs in the mutation.
func (m *MerchantStoreMutation) OrderDetailsIDs() (ids []int) {
	for id := range m.order_details {
		ids = append(ids, id)
	}
	return
}

// ResetOrderDetails resets all changes to the "order_details" edge.
func (m *MerchantStoreMutation) ResetOrderDetails() {
	m.order_details = nil
	m.clearedorder_details = false
	m.removedorder_details = nil
}

// Where appends a list predicates to the MerchantStoreMutation builder.
func (m *MerchantStoreMutation) Where(ps ...predicate.MerchantStore) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MerchantStoreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MerchantStore).
func (m *MerchantStoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantStoreMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, merchantstore.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, merchantstore.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, merchantstore.FieldName)
	}
	if m.about != nil {
		fields = append(fields, merchantstore.FieldAbout)
	}
	if m.desc_title != nil {
		fields = append(fields, merchantstore.FieldDescTitle)
	}
	if m.description != nil {
		fields = append(fields, merchantstore.FieldDescription)
	}
	if m.logo != nil {
		fields = append(fields, merchantstore.FieldLogo)
	}
	if m.images != nil {
		fields = append(fields, merchantstore.FieldImages)
	}
	if m.region != nil {
		fields = append(fields, merchantstore.FieldRegion)
	}
	if m.district != nil {
		fields = append(fields, merchantstore.FieldDistrict)
	}
	if m.city != nil {
		fields = append(fields, merchantstore.FieldCity)
	}
	if m.default_account != nil {
		fields = append(fields, merchantstore.FieldDefaultAccount)
	}
	if m.bank_account != nil {
		fields = append(fields, merchantstore.FieldBankAccount)
	}
	if m.momo_account != nil {
		fields = append(fields, merchantstore.FieldMomoAccount)
	}
	if m.merchant_type != nil {
		fields = append(fields, merchantstore.FieldMerchantType)
	}
	if m.permit_agent != nil {
		fields = append(fields, merchantstore.FieldPermitAgent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantStoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchantstore.FieldCreatedAt:
		return m.CreatedAt()
	case merchantstore.FieldUpdatedAt:
		return m.UpdatedAt()
	case merchantstore.FieldName:
		return m.Name()
	case merchantstore.FieldAbout:
		return m.About()
	case merchantstore.FieldDescTitle:
		return m.DescTitle()
	case merchantstore.FieldDescription:
		return m.Description()
	case merchantstore.FieldLogo:
		return m.Logo()
	case merchantstore.FieldImages:
		return m.Images()
	case merchantstore.FieldRegion:
		return m.Region()
	case merchantstore.FieldDistrict:
		return m.District()
	case merchantstore.FieldCity:
		return m.City()
	case merchantstore.FieldDefaultAccount:
		return m.DefaultAccount()
	case merchantstore.FieldBankAccount:
		return m.BankAccount()
	case merchantstore.FieldMomoAccount:
		return m.MomoAccount()
	case merchantstore.FieldMerchantType:
		return m.MerchantType()
	case merchantstore.FieldPermitAgent:
		return m.PermitAgent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantStoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchantstore.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case merchantstore.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case merchantstore.FieldName:
		return m.OldName(ctx)
	case merchantstore.FieldAbout:
		return m.OldAbout(ctx)
	case merchantstore.FieldDescTitle:
		return m.OldDescTitle(ctx)
	case merchantstore.FieldDescription:
		return m.OldDescription(ctx)
	case merchantstore.FieldLogo:
		return m.OldLogo(ctx)
	case merchantstore.FieldImages:
		return m.OldImages(ctx)
	case merchantstore.FieldRegion:
		return m.OldRegion(ctx)
	case merchantstore.FieldDistrict:
		return m.OldDistrict(ctx)
	case merchantstore.FieldCity:
		return m.OldCity(ctx)
	case merchantstore.FieldDefaultAccount:
		return m.OldDefaultAccount(ctx)
	case merchantstore.FieldBankAccount:
		return m.OldBankAccount(ctx)
	case merchantstore.FieldMomoAccount:
		return m.OldMomoAccount(ctx)
	case merchantstore.FieldMerchantType:
		return m.OldMerchantType(ctx)
	case merchantstore.FieldPermitAgent:
		return m.OldPermitAgent(ctx)
	}
	return nil, fmt.Errorf("unknown MerchantStore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantStoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchantstore.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case merchantstore.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case merchantstore.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case merchantstore.FieldAbout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbout(v)
		return nil
	case merchantstore.FieldDescTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescTitle(v)
		return nil
	case merchantstore.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case merchantstore.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case merchantstore.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case merchantstore.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case merchantstore.FieldDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrict(v)
		return nil
	case merchantstore.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case merchantstore.FieldDefaultAccount:
		v, ok := value.(merchantstore.DefaultAccount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultAccount(v)
		return nil
	case merchantstore.FieldBankAccount:
		v, ok := value.(*models.MerchantBankAccount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccount(v)
		return nil
	case merchantstore.FieldMomoAccount:
		v, ok := value.(*models.MerchantMomoAccount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMomoAccount(v)
		return nil
	case merchantstore.FieldMerchantType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantType(v)
		return nil
	case merchantstore.FieldPermitAgent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermitAgent(v)
		return nil
	}
	return fmt.Errorf("unknown MerchantStore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantStoreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantStoreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantStoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MerchantStore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantStoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(merchantstore.FieldImages) {
		fields = append(fields, merchantstore.FieldImages)
	}
	if m.FieldCleared(merchantstore.FieldRegion) {
		fields = append(fields, merchantstore.FieldRegion)
	}
	if m.FieldCleared(merchantstore.FieldDistrict) {
		fields = append(fields, merchantstore.FieldDistrict)
	}
	if m.FieldCleared(merchantstore.FieldCity) {
		fields = append(fields, merchantstore.FieldCity)
	}
	if m.FieldCleared(merchantstore.FieldDefaultAccount) {
		fields = append(fields, merchantstore.FieldDefaultAccount)
	}
	if m.FieldCleared(merchantstore.FieldBankAccount) {
		fields = append(fields, merchantstore.FieldBankAccount)
	}
	if m.FieldCleared(merchantstore.FieldMomoAccount) {
		fields = append(fields, merchantstore.FieldMomoAccount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantStoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantStoreMutation) ClearField(name string) error {
	switch name {
	case merchantstore.FieldImages:
		m.ClearImages()
		return nil
	case merchantstore.FieldRegion:
		m.ClearRegion()
		return nil
	case merchantstore.FieldDistrict:
		m.ClearDistrict()
		return nil
	case merchantstore.FieldCity:
		m.ClearCity()
		return nil
	case merchantstore.FieldDefaultAccount:
		m.ClearDefaultAccount()
		return nil
	case merchantstore.FieldBankAccount:
		m.ClearBankAccount()
		return nil
	case merchantstore.FieldMomoAccount:
		m.ClearMomoAccount()
		return nil
	}
	return fmt.Errorf("unknown MerchantStore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantStoreMutation) ResetField(name string) error {
	switch name {
	case merchantstore.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case merchantstore.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case merchantstore.FieldName:
		m.ResetName()
		return nil
	case merchantstore.FieldAbout:
		m.ResetAbout()
		return nil
	case merchantstore.FieldDescTitle:
		m.ResetDescTitle()
		return nil
	case merchantstore.FieldDescription:
		m.ResetDescription()
		return nil
	case merchantstore.FieldLogo:
		m.ResetLogo()
		return nil
	case merchantstore.FieldImages:
		m.ResetImages()
		return nil
	case merchantstore.FieldRegion:
		m.ResetRegion()
		return nil
	case merchantstore.FieldDistrict:
		m.ResetDistrict()
		return nil
	case merchantstore.FieldCity:
		m.ResetCity()
		return nil
	case merchantstore.FieldDefaultAccount:
		m.ResetDefaultAccount()
		return nil
	case merchantstore.FieldBankAccount:
		m.ResetBankAccount()
		return nil
	case merchantstore.FieldMomoAccount:
		m.ResetMomoAccount()
		return nil
	case merchantstore.FieldMerchantType:
		m.ResetMerchantType()
		return nil
	case merchantstore.FieldPermitAgent:
		m.ResetPermitAgent()
		return nil
	}
	return fmt.Errorf("unknown MerchantStore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantStoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.merchant != nil {
		edges = append(edges, merchantstore.EdgeMerchant)
	}
	if m.agent != nil {
		edges = append(edges, merchantstore.EdgeAgent)
	}
	if m.requests != nil {
		edges = append(edges, merchantstore.EdgeRequests)
	}
	if m.orders != nil {
		edges = append(edges, merchantstore.EdgeOrders)
	}
	if m.order_details != nil {
		edges = append(edges, merchantstore.EdgeOrderDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantStoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case merchantstore.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case merchantstore.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case merchantstore.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case merchantstore.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case merchantstore.EdgeOrderDetails:
		ids := make([]ent.Value, 0, len(m.order_details))
		for id := range m.order_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantStoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrequests != nil {
		edges = append(edges, merchantstore.EdgeRequests)
	}
	if m.removedorders != nil {
		edges = append(edges, merchantstore.EdgeOrders)
	}
	if m.removedorder_details != nil {
		edges = append(edges, merchantstore.EdgeOrderDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantStoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case merchantstore.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case merchantstore.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case merchantstore.EdgeOrderDetails:
		ids := make([]ent.Value, 0, len(m.removedorder_details))
		for id := range m.removedorder_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantStoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedmerchant {
		edges = append(edges, merchantstore.EdgeMerchant)
	}
	if m.clearedagent {
		edges = append(edges, merchantstore.EdgeAgent)
	}
	if m.clearedrequests {
		edges = append(edges, merchantstore.EdgeRequests)
	}
	if m.clearedorders {
		edges = append(edges, merchantstore.EdgeOrders)
	}
	if m.clearedorder_details {
		edges = append(edges, merchantstore.EdgeOrderDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantStoreMutation) EdgeCleared(name string) bool {
	switch name {
	case merchantstore.EdgeMerchant:
		return m.clearedmerchant
	case merchantstore.EdgeAgent:
		return m.clearedagent
	case merchantstore.EdgeRequests:
		return m.clearedrequests
	case merchantstore.EdgeOrders:
		return m.clearedorders
	case merchantstore.EdgeOrderDetails:
		return m.clearedorder_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantStoreMutation) ClearEdge(name string) error {
	switch name {
	case merchantstore.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case merchantstore.EdgeAgent:
		m.ClearAgent()
		return nil
	}
	return fmt.Errorf("unknown MerchantStore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantStoreMutation) ResetEdge(name string) error {
	switch name {
	case merchantstore.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case merchantstore.EdgeAgent:
		m.ResetAgent()
		return nil
	case merchantstore.EdgeRequests:
		m.ResetRequests()
		return nil
	case merchantstore.EdgeOrders:
		m.ResetOrders()
		return nil
	case merchantstore.EdgeOrderDetails:
		m.ResetOrderDetails()
		return nil
	}
	return fmt.Errorf("unknown MerchantStore edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	order_number    *string
	currency        *string
	amount          *float64
	addamount       *float64
	delivery_fee    *float64
	adddelivery_fee *float64
	reference       *string
	channel         *string
	paid_at         *string
	delivery_method *order.DeliveryMethod
	payment_method  *order.PaymentMethod
	status          *order.Status
	delivered_at    *time.Time
	clearedFields   map[string]struct{}
	details         map[int]struct{}
	removeddetails  map[int]struct{}
	cleareddetails  bool
	merchant        *int
	clearedmerchant bool
	agent           *int
	clearedagent    bool
	customer        *int
	clearedcustomer bool
	address         *int
	clearedaddress  bool
	pickup          *int
	clearedpickup   bool
	stores          map[int]struct{}
	removedstores   map[int]struct{}
	clearedstores   bool
	done            bool
	oldValue        func(context.Context) (*Order, error)
	predicates      []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrderNumber sets the "order_number" field.
func (m *OrderMutation) SetOrderNumber(s string) {
	m.order_number = &s
}

// OrderNumber returns the value of the "order_number" field in the mutation.
func (m *OrderMutation) OrderNumber() (r string, exists bool) {
	v := m.order_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "order_number" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "order_number" field.
func (m *OrderMutation) ResetOrderNumber() {
	m.order_number = nil
}

// SetCurrency sets the "currency" field.
func (m *OrderMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *OrderMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *OrderMutation) ResetCurrency() {
	m.currency = nil
}

// SetAmount sets the "amount" field.
func (m *OrderMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *OrderMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *OrderMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetDeliveryFee sets the "delivery_fee" field.
func (m *OrderMutation) SetDeliveryFee(f float64) {
	m.delivery_fee = &f
	m.adddelivery_fee = nil
}

// DeliveryFee returns the value of the "delivery_fee" field in the mutation.
func (m *OrderMutation) DeliveryFee() (r float64, exists bool) {
	v := m.delivery_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryFee returns the old "delivery_fee" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeliveryFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryFee: %w", err)
	}
	return oldValue.DeliveryFee, nil
}

// AddDeliveryFee adds f to the "delivery_fee" field.
func (m *OrderMutation) AddDeliveryFee(f float64) {
	if m.adddelivery_fee != nil {
		*m.adddelivery_fee += f
	} else {
		m.adddelivery_fee = &f
	}
}

// AddedDeliveryFee returns the value that was added to the "delivery_fee" field in this mutation.
func (m *OrderMutation) AddedDeliveryFee() (r float64, exists bool) {
	v := m.adddelivery_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeliveryFee resets all changes to the "delivery_fee" field.
func (m *OrderMutation) ResetDeliveryFee() {
	m.delivery_fee = nil
	m.adddelivery_fee = nil
}

// SetReference sets the "reference" field.
func (m *OrderMutation) SetReference(s string) {
	m.reference = &s
}

// Reference returns the value of the "reference" field in the mutation.
func (m *OrderMutation) Reference() (r string, exists bool) {
	v := m.reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "reference" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldReference(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// ClearReference clears the value of the "reference" field.
func (m *OrderMutation) ClearReference() {
	m.reference = nil
	m.clearedFields[order.FieldReference] = struct{}{}
}

// ReferenceCleared returns if the "reference" field was cleared in this mutation.
func (m *OrderMutation) ReferenceCleared() bool {
	_, ok := m.clearedFields[order.FieldReference]
	return ok
}

// ResetReference resets all changes to the "reference" field.
func (m *OrderMutation) ResetReference() {
	m.reference = nil
	delete(m.clearedFields, order.FieldReference)
}

// SetChannel sets the "channel" field.
func (m *OrderMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *OrderMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldChannel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ClearChannel clears the value of the "channel" field.
func (m *OrderMutation) ClearChannel() {
	m.channel = nil
	m.clearedFields[order.FieldChannel] = struct{}{}
}

// ChannelCleared returns if the "channel" field was cleared in this mutation.
func (m *OrderMutation) ChannelCleared() bool {
	_, ok := m.clearedFields[order.FieldChannel]
	return ok
}

// ResetChannel resets all changes to the "channel" field.
func (m *OrderMutation) ResetChannel() {
	m.channel = nil
	delete(m.clearedFields, order.FieldChannel)
}

// SetPaidAt sets the "paid_at" field.
func (m *OrderMutation) SetPaidAt(s string) {
	m.paid_at = &s
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *OrderMutation) PaidAt() (r string, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaidAt(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *OrderMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[order.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *OrderMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[order.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *OrderMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, order.FieldPaidAt)
}

// SetDeliveryMethod sets the "delivery_method" field.
func (m *OrderMutation) SetDeliveryMethod(om order.DeliveryMethod) {
	m.delivery_method = &om
}

// DeliveryMethod returns the value of the "delivery_method" field in the mutation.
func (m *OrderMutation) DeliveryMethod() (r order.DeliveryMethod, exists bool) {
	v := m.delivery_method
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryMethod returns the old "delivery_method" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeliveryMethod(ctx context.Context) (v order.DeliveryMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryMethod: %w", err)
	}
	return oldValue.DeliveryMethod, nil
}

// ResetDeliveryMethod resets all changes to the "delivery_method" field.
func (m *OrderMutation) ResetDeliveryMethod() {
	m.delivery_method = nil
}

// SetPaymentMethod sets the "payment_method" field.
func (m *OrderMutation) SetPaymentMethod(om order.PaymentMethod) {
	m.payment_method = &om
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *OrderMutation) PaymentMethod() (r order.PaymentMethod, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaymentMethod(ctx context.Context) (v order.PaymentMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *OrderMutation) ResetPaymentMethod() {
	m.payment_method = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetDeliveredAt sets the "delivered_at" field.
func (m *OrderMutation) SetDeliveredAt(t time.Time) {
	m.delivered_at = &t
}

// DeliveredAt returns the value of the "delivered_at" field in the mutation.
func (m *OrderMutation) DeliveredAt() (r time.Time, exists bool) {
	v := m.delivered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveredAt returns the old "delivered_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeliveredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveredAt: %w", err)
	}
	return oldValue.DeliveredAt, nil
}

// ClearDeliveredAt clears the value of the "delivered_at" field.
func (m *OrderMutation) ClearDeliveredAt() {
	m.delivered_at = nil
	m.clearedFields[order.FieldDeliveredAt] = struct{}{}
}

// DeliveredAtCleared returns if the "delivered_at" field was cleared in this mutation.
func (m *OrderMutation) DeliveredAtCleared() bool {
	_, ok := m.clearedFields[order.FieldDeliveredAt]
	return ok
}

// ResetDeliveredAt resets all changes to the "delivered_at" field.
func (m *OrderMutation) ResetDeliveredAt() {
	m.delivered_at = nil
	delete(m.clearedFields, order.FieldDeliveredAt)
}

// AddDetailIDs adds the "details" edge to the OrderDetail entity by ids.
func (m *OrderMutation) AddDetailIDs(ids ...int) {
	if m.details == nil {
		m.details = make(map[int]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// ClearDetails clears the "details" edge to the OrderDetail entity.
func (m *OrderMutation) ClearDetails() {
	m.cleareddetails = true
}

// DetailsCleared reports if the "details" edge to the OrderDetail entity was cleared.
func (m *OrderMutation) DetailsCleared() bool {
	return m.cleareddetails
}

// RemoveDetailIDs removes the "details" edge to the OrderDetail entity by IDs.
func (m *OrderMutation) RemoveDetailIDs(ids ...int) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.details, ids[i])
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed IDs of the "details" edge to the OrderDetail entity.
func (m *OrderMutation) RemovedDetailsIDs() (ids []int) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the "details" edge IDs in the mutation.
func (m *OrderMutation) DetailsIDs() (ids []int) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails resets all changes to the "details" edge.
func (m *OrderMutation) ResetDetails() {
	m.details = nil
	m.cleareddetails = false
	m.removeddetails = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *OrderMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *OrderMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *OrderMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *OrderMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *OrderMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *OrderMutation) SetAgentID(id int) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *OrderMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *OrderMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *OrderMutation) AgentID() (id int, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) AgentIDs() (ids []int) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *OrderMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *OrderMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *OrderMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *OrderMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *OrderMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *OrderMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetAddressID sets the "address" edge to the Address entity by id.
func (m *OrderMutation) SetAddressID(id int) {
	m.address = &id
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *OrderMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *OrderMutation) AddressCleared() bool {
	return m.clearedaddress
}

// AddressID returns the "address" edge ID in the mutation.
func (m *OrderMutation) AddressID() (id int, exists bool) {
	if m.address != nil {
		return *m.address, true
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) AddressIDs() (ids []int) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *OrderMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// SetPickupID sets the "pickup" edge to the PickupStation entity by id.
func (m *OrderMutation) SetPickupID(id int) {
	m.pickup = &id
}

// ClearPickup clears the "pickup" edge to the PickupStation entity.
func (m *OrderMutation) ClearPickup() {
	m.clearedpickup = true
}

// PickupCleared reports if the "pickup" edge to the PickupStation entity was cleared.
func (m *OrderMutation) PickupCleared() bool {
	return m.clearedpickup
}

// PickupID returns the "pickup" edge ID in the mutation.
func (m *OrderMutation) PickupID() (id int, exists bool) {
	if m.pickup != nil {
		return *m.pickup, true
	}
	return
}

// PickupIDs returns the "pickup" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PickupID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) PickupIDs() (ids []int) {
	if id := m.pickup; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPickup resets all changes to the "pickup" edge.
func (m *OrderMutation) ResetPickup() {
	m.pickup = nil
	m.clearedpickup = false
}

// AddStoreIDs adds the "stores" edge to the MerchantStore entity by ids.
func (m *OrderMutation) AddStoreIDs(ids ...int) {
	if m.stores == nil {
		m.stores = make(map[int]struct{})
	}
	for i := range ids {
		m.stores[ids[i]] = struct{}{}
	}
}

// ClearStores clears the "stores" edge to the MerchantStore entity.
func (m *OrderMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the MerchantStore entity was cleared.
func (m *OrderMutation) StoresCleared() bool {
	return m.clearedstores
}

// RemoveStoreIDs removes the "stores" edge to the MerchantStore entity by IDs.
func (m *OrderMutation) RemoveStoreIDs(ids ...int) {
	if m.removedstores == nil {
		m.removedstores = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stores, ids[i])
		m.removedstores[ids[i]] = struct{}{}
	}
}

// RemovedStores returns the removed IDs of the "stores" edge to the MerchantStore entity.
func (m *OrderMutation) RemovedStoresIDs() (ids []int) {
	for id := range m.removedstores {
		ids = append(ids, id)
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
func (m *OrderMutation) StoresIDs() (ids []int) {
	for id := range m.stores {
		ids = append(ids, id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *OrderMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
	m.removedstores = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.order_number != nil {
		fields = append(fields, order.FieldOrderNumber)
	}
	if m.currency != nil {
		fields = append(fields, order.FieldCurrency)
	}
	if m.amount != nil {
		fields = append(fields, order.FieldAmount)
	}
	if m.delivery_fee != nil {
		fields = append(fields, order.FieldDeliveryFee)
	}
	if m.reference != nil {
		fields = append(fields, order.FieldReference)
	}
	if m.channel != nil {
		fields = append(fields, order.FieldChannel)
	}
	if m.paid_at != nil {
		fields = append(fields, order.FieldPaidAt)
	}
	if m.delivery_method != nil {
		fields = append(fields, order.FieldDeliveryMethod)
	}
	if m.payment_method != nil {
		fields = append(fields, order.FieldPaymentMethod)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.delivered_at != nil {
		fields = append(fields, order.FieldDeliveredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldOrderNumber:
		return m.OrderNumber()
	case order.FieldCurrency:
		return m.Currency()
	case order.FieldAmount:
		return m.Amount()
	case order.FieldDeliveryFee:
		return m.DeliveryFee()
	case order.FieldReference:
		return m.Reference()
	case order.FieldChannel:
		return m.Channel()
	case order.FieldPaidAt:
		return m.PaidAt()
	case order.FieldDeliveryMethod:
		return m.DeliveryMethod()
	case order.FieldPaymentMethod:
		return m.PaymentMethod()
	case order.FieldStatus:
		return m.Status()
	case order.FieldDeliveredAt:
		return m.DeliveredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case order.FieldCurrency:
		return m.OldCurrency(ctx)
	case order.FieldAmount:
		return m.OldAmount(ctx)
	case order.FieldDeliveryFee:
		return m.OldDeliveryFee(ctx)
	case order.FieldReference:
		return m.OldReference(ctx)
	case order.FieldChannel:
		return m.OldChannel(ctx)
	case order.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case order.FieldDeliveryMethod:
		return m.OldDeliveryMethod(ctx)
	case order.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldDeliveredAt:
		return m.OldDeliveredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case order.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case order.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case order.FieldDeliveryFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryFee(v)
		return nil
	case order.FieldReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	case order.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case order.FieldPaidAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case order.FieldDeliveryMethod:
		v, ok := value.(order.DeliveryMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryMethod(v)
		return nil
	case order.FieldPaymentMethod:
		v, ok := value.(order.PaymentMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldDeliveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, order.FieldAmount)
	}
	if m.adddelivery_fee != nil {
		fields = append(fields, order.FieldDeliveryFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldAmount:
		return m.AddedAmount()
	case order.FieldDeliveryFee:
		return m.AddedDeliveryFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case order.FieldDeliveryFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryFee(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldReference) {
		fields = append(fields, order.FieldReference)
	}
	if m.FieldCleared(order.FieldChannel) {
		fields = append(fields, order.FieldChannel)
	}
	if m.FieldCleared(order.FieldPaidAt) {
		fields = append(fields, order.FieldPaidAt)
	}
	if m.FieldCleared(order.FieldDeliveredAt) {
		fields = append(fields, order.FieldDeliveredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldReference:
		m.ClearReference()
		return nil
	case order.FieldChannel:
		m.ClearChannel()
		return nil
	case order.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	case order.FieldDeliveredAt:
		m.ClearDeliveredAt()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case order.FieldCurrency:
		m.ResetCurrency()
		return nil
	case order.FieldAmount:
		m.ResetAmount()
		return nil
	case order.FieldDeliveryFee:
		m.ResetDeliveryFee()
		return nil
	case order.FieldReference:
		m.ResetReference()
		return nil
	case order.FieldChannel:
		m.ResetChannel()
		return nil
	case order.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case order.FieldDeliveryMethod:
		m.ResetDeliveryMethod()
		return nil
	case order.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldDeliveredAt:
		m.ResetDeliveredAt()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.details != nil {
		edges = append(edges, order.EdgeDetails)
	}
	if m.merchant != nil {
		edges = append(edges, order.EdgeMerchant)
	}
	if m.agent != nil {
		edges = append(edges, order.EdgeAgent)
	}
	if m.customer != nil {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.address != nil {
		edges = append(edges, order.EdgeAddress)
	}
	if m.pickup != nil {
		edges = append(edges, order.EdgePickup)
	}
	if m.stores != nil {
		edges = append(edges, order.EdgeStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgePickup:
		if id := m.pickup; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeStores:
		ids := make([]ent.Value, 0, len(m.stores))
		for id := range m.stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removeddetails != nil {
		edges = append(edges, order.EdgeDetails)
	}
	if m.removedstores != nil {
		edges = append(edges, order.EdgeStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeStores:
		ids := make([]ent.Value, 0, len(m.removedstores))
		for id := range m.removedstores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareddetails {
		edges = append(edges, order.EdgeDetails)
	}
	if m.clearedmerchant {
		edges = append(edges, order.EdgeMerchant)
	}
	if m.clearedagent {
		edges = append(edges, order.EdgeAgent)
	}
	if m.clearedcustomer {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.clearedaddress {
		edges = append(edges, order.EdgeAddress)
	}
	if m.clearedpickup {
		edges = append(edges, order.EdgePickup)
	}
	if m.clearedstores {
		edges = append(edges, order.EdgeStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeDetails:
		return m.cleareddetails
	case order.EdgeMerchant:
		return m.clearedmerchant
	case order.EdgeAgent:
		return m.clearedagent
	case order.EdgeCustomer:
		return m.clearedcustomer
	case order.EdgeAddress:
		return m.clearedaddress
	case order.EdgePickup:
		return m.clearedpickup
	case order.EdgeStores:
		return m.clearedstores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case order.EdgeAgent:
		m.ClearAgent()
		return nil
	case order.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case order.EdgeAddress:
		m.ClearAddress()
		return nil
	case order.EdgePickup:
		m.ClearPickup()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeDetails:
		m.ResetDetails()
		return nil
	case order.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case order.EdgeAgent:
		m.ResetAgent()
		return nil
	case order.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case order.EdgeAddress:
		m.ResetAddress()
		return nil
	case order.EdgePickup:
		m.ResetPickup()
		return nil
	case order.EdgeStores:
		m.ResetStores()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderDetailMutation represents an operation that mutates the OrderDetail nodes in the graph.
type OrderDetailMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	price          *float64
	addprice       *float64
	promo_price    *float64
	addpromo_price *float64
	amount         *float64
	addamount      *float64
	quantity       *int
	addquantity    *int
	status         *orderdetail.Status
	clearedFields  map[string]struct{}
	_Order         *int
	cleared_Order  bool
	product        *int
	clearedproduct bool
	store          *int
	clearedstore   bool
	done           bool
	oldValue       func(context.Context) (*OrderDetail, error)
	predicates     []predicate.OrderDetail
}

var _ ent.Mutation = (*OrderDetailMutation)(nil)

// orderdetailOption allows management of the mutation configuration using functional options.
type orderdetailOption func(*OrderDetailMutation)

// newOrderDetailMutation creates new mutation for the OrderDetail entity.
func newOrderDetailMutation(c config, op Op, opts ...orderdetailOption) *OrderDetailMutation {
	m := &OrderDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderDetailID sets the ID field of the mutation.
func withOrderDetailID(id int) orderdetailOption {
	return func(m *OrderDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderDetail
		)
		m.oldValue = func(ctx context.Context) (*OrderDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderDetail sets the old OrderDetail of the mutation.
func withOrderDetail(node *OrderDetail) orderdetailOption {
	return func(m *OrderDetailMutation) {
		m.oldValue = func(context.Context) (*OrderDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPrice sets the "price" field.
func (m *OrderDetailMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderDetailMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *OrderDetailMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *OrderDetailMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderDetailMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetPromoPrice sets the "promo_price" field.
func (m *OrderDetailMutation) SetPromoPrice(f float64) {
	m.promo_price = &f
	m.addpromo_price = nil
}

// PromoPrice returns the value of the "promo_price" field in the mutation.
func (m *OrderDetailMutation) PromoPrice() (r float64, exists bool) {
	v := m.promo_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPromoPrice returns the old "promo_price" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldPromoPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromoPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromoPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromoPrice: %w", err)
	}
	return oldValue.PromoPrice, nil
}

// AddPromoPrice adds f to the "promo_price" field.
func (m *OrderDetailMutation) AddPromoPrice(f float64) {
	if m.addpromo_price != nil {
		*m.addpromo_price += f
	} else {
		m.addpromo_price = &f
	}
}

// AddedPromoPrice returns the value that was added to the "promo_price" field in this mutation.
func (m *OrderDetailMutation) AddedPromoPrice() (r float64, exists bool) {
	v := m.addpromo_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPromoPrice resets all changes to the "promo_price" field.
func (m *OrderDetailMutation) ResetPromoPrice() {
	m.promo_price = nil
	m.addpromo_price = nil
}

// SetAmount sets the "amount" field.
func (m *OrderDetailMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderDetailMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *OrderDetailMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *OrderDetailMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderDetailMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetQuantity sets the "quantity" field.
func (m *OrderDetailMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderDetailMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *OrderDetailMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderDetailMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderDetailMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetStatus sets the "status" field.
func (m *OrderDetailMutation) SetStatus(o orderdetail.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderDetailMutation) Status() (r orderdetail.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldStatus(ctx context.Context) (v orderdetail.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderDetailMutation) ResetStatus() {
	m.status = nil
}

// SetOrderID sets the "Order" edge to the Order entity by id.
func (m *OrderDetailMutation) SetOrderID(id int) {
	m._Order = &id
}

// ClearOrder clears the "Order" edge to the Order entity.
func (m *OrderDetailMutation) ClearOrder() {
	m.cleared_Order = true
}

// OrderCleared reports if the "Order" edge to the Order entity was cleared.
func (m *OrderDetailMutation) OrderCleared() bool {
	return m.cleared_Order
}

// OrderID returns the "Order" edge ID in the mutation.
func (m *OrderDetailMutation) OrderID() (id int, exists bool) {
	if m._Order != nil {
		return *m._Order, true
	}
	return
}

// OrderIDs returns the "Order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderDetailMutation) OrderIDs() (ids []int) {
	if id := m._Order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "Order" edge.
func (m *OrderDetailMutation) ResetOrder() {
	m._Order = nil
	m.cleared_Order = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *OrderDetailMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *OrderDetailMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *OrderDetailMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *OrderDetailMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *OrderDetailMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *OrderDetailMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// SetStoreID sets the "store" edge to the MerchantStore entity by id.
func (m *OrderDetailMutation) SetStoreID(id int) {
	m.store = &id
}

// ClearStore clears the "store" edge to the MerchantStore entity.
func (m *OrderDetailMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the MerchantStore entity was cleared.
func (m *OrderDetailMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreID returns the "store" edge ID in the mutation.
func (m *OrderDetailMutation) StoreID() (id int, exists bool) {
	if m.store != nil {
		return *m.store, true
	}
	return
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *OrderDetailMutation) StoreIDs() (ids []int) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *OrderDetailMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the OrderDetailMutation builder.
func (m *OrderDetailMutation) Where(ps ...predicate.OrderDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderDetail).
func (m *OrderDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderDetailMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, orderdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderdetail.FieldUpdatedAt)
	}
	if m.price != nil {
		fields = append(fields, orderdetail.FieldPrice)
	}
	if m.promo_price != nil {
		fields = append(fields, orderdetail.FieldPromoPrice)
	}
	if m.amount != nil {
		fields = append(fields, orderdetail.FieldAmount)
	}
	if m.quantity != nil {
		fields = append(fields, orderdetail.FieldQuantity)
	}
	if m.status != nil {
		fields = append(fields, orderdetail.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderdetail.FieldCreatedAt:
		return m.CreatedAt()
	case orderdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderdetail.FieldPrice:
		return m.Price()
	case orderdetail.FieldPromoPrice:
		return m.PromoPrice()
	case orderdetail.FieldAmount:
		return m.Amount()
	case orderdetail.FieldQuantity:
		return m.Quantity()
	case orderdetail.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderdetail.FieldPrice:
		return m.OldPrice(ctx)
	case orderdetail.FieldPromoPrice:
		return m.OldPromoPrice(ctx)
	case orderdetail.FieldAmount:
		return m.OldAmount(ctx)
	case orderdetail.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderdetail.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown OrderDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderdetail.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case orderdetail.FieldPromoPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromoPrice(v)
		return nil
	case orderdetail.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case orderdetail.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderdetail.FieldStatus:
		v, ok := value.(orderdetail.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OrderDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderDetailMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, orderdetail.FieldPrice)
	}
	if m.addpromo_price != nil {
		fields = append(fields, orderdetail.FieldPromoPrice)
	}
	if m.addamount != nil {
		fields = append(fields, orderdetail.FieldAmount)
	}
	if m.addquantity != nil {
		fields = append(fields, orderdetail.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderdetail.FieldPrice:
		return m.AddedPrice()
	case orderdetail.FieldPromoPrice:
		return m.AddedPromoPrice()
	case orderdetail.FieldAmount:
		return m.AddedAmount()
	case orderdetail.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderdetail.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case orderdetail.FieldPromoPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromoPrice(v)
		return nil
	case orderdetail.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case orderdetail.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown OrderDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderDetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderDetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderDetailMutation) ResetField(name string) error {
	switch name {
	case orderdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderdetail.FieldPrice:
		m.ResetPrice()
		return nil
	case orderdetail.FieldPromoPrice:
		m.ResetPromoPrice()
		return nil
	case orderdetail.FieldAmount:
		m.ResetAmount()
		return nil
	case orderdetail.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderdetail.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown OrderDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Order != nil {
		edges = append(edges, orderdetail.EdgeOrder)
	}
	if m.product != nil {
		edges = append(edges, orderdetail.EdgeProduct)
	}
	if m.store != nil {
		edges = append(edges, orderdetail.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderdetail.EdgeOrder:
		if id := m._Order; id != nil {
			return []ent.Value{*id}
		}
	case orderdetail.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case orderdetail.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Order {
		edges = append(edges, orderdetail.EdgeOrder)
	}
	if m.clearedproduct {
		edges = append(edges, orderdetail.EdgeProduct)
	}
	if m.clearedstore {
		edges = append(edges, orderdetail.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case orderdetail.EdgeOrder:
		return m.cleared_Order
	case orderdetail.EdgeProduct:
		return m.clearedproduct
	case orderdetail.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderDetailMutation) ClearEdge(name string) error {
	switch name {
	case orderdetail.EdgeOrder:
		m.ClearOrder()
		return nil
	case orderdetail.EdgeProduct:
		m.ClearProduct()
		return nil
	case orderdetail.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown OrderDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderDetailMutation) ResetEdge(name string) error {
	switch name {
	case orderdetail.EdgeOrder:
		m.ResetOrder()
		return nil
	case orderdetail.EdgeProduct:
		m.ResetProduct()
		return nil
	case orderdetail.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown OrderDetail edge %s", name)
}

// PickupStationMutation represents an operation that mutates the PickupStation nodes in the graph.
type PickupStationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	region        *string
	city          *string
	name          *string
	address       *string
	clearedFields map[string]struct{}
	orders        map[int]struct{}
	removedorders map[int]struct{}
	clearedorders bool
	done          bool
	oldValue      func(context.Context) (*PickupStation, error)
	predicates    []predicate.PickupStation
}

var _ ent.Mutation = (*PickupStationMutation)(nil)

// pickupstationOption allows management of the mutation configuration using functional options.
type pickupstationOption func(*PickupStationMutation)

// newPickupStationMutation creates new mutation for the PickupStation entity.
func newPickupStationMutation(c config, op Op, opts ...pickupstationOption) *PickupStationMutation {
	m := &PickupStationMutation{
		config:        c,
		op:            op,
		typ:           TypePickupStation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPickupStationID sets the ID field of the mutation.
func withPickupStationID(id int) pickupstationOption {
	return func(m *PickupStationMutation) {
		var (
			err   error
			once  sync.Once
			value *PickupStation
		)
		m.oldValue = func(ctx context.Context) (*PickupStation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PickupStation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPickupStation sets the old PickupStation of the mutation.
func withPickupStation(node *PickupStation) pickupstationOption {
	return func(m *PickupStationMutation) {
		m.oldValue = func(context.Context) (*PickupStation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PickupStationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PickupStationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PickupStationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PickupStationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PickupStation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PickupStationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PickupStationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PickupStation entity.
// If the PickupStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupStationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PickupStationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PickupStationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PickupStationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PickupStation entity.
// If the PickupStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupStationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PickupStationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRegion sets the "region" field.
func (m *PickupStationMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *PickupStationMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the PickupStation entity.
// If the PickupStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupStationMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *PickupStationMutation) ResetRegion() {
	m.region = nil
}

// SetCity sets the "city" field.
func (m *PickupStationMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *PickupStationMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the PickupStation entity.
// If the PickupStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupStationMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *PickupStationMutation) ResetCity() {
	m.city = nil
}

// SetName sets the "name" field.
func (m *PickupStationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PickupStationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PickupStation entity.
// If the PickupStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupStationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PickupStationMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the "address" field.
func (m *PickupStationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PickupStationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the PickupStation entity.
// If the PickupStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PickupStationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *PickupStationMutation) ResetAddress() {
	m.address = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *PickupStationMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *PickupStationMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *PickupStationMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *PickupStationMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *PickupStationMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *PickupStationMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *PickupStationMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the PickupStationMutation builder.
func (m *PickupStationMutation) Where(ps ...predicate.PickupStation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PickupStationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PickupStation).
func (m *PickupStationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PickupStationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, pickupstation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pickupstation.FieldUpdatedAt)
	}
	if m.region != nil {
		fields = append(fields, pickupstation.FieldRegion)
	}
	if m.city != nil {
		fields = append(fields, pickupstation.FieldCity)
	}
	if m.name != nil {
		fields = append(fields, pickupstation.FieldName)
	}
	if m.address != nil {
		fields = append(fields, pickupstation.FieldAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PickupStationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pickupstation.FieldCreatedAt:
		return m.CreatedAt()
	case pickupstation.FieldUpdatedAt:
		return m.UpdatedAt()
	case pickupstation.FieldRegion:
		return m.Region()
	case pickupstation.FieldCity:
		return m.City()
	case pickupstation.FieldName:
		return m.Name()
	case pickupstation.FieldAddress:
		return m.Address()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PickupStationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pickupstation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pickupstation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pickupstation.FieldRegion:
		return m.OldRegion(ctx)
	case pickupstation.FieldCity:
		return m.OldCity(ctx)
	case pickupstation.FieldName:
		return m.OldName(ctx)
	case pickupstation.FieldAddress:
		return m.OldAddress(ctx)
	}
	return nil, fmt.Errorf("unknown PickupStation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PickupStationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pickupstation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pickupstation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pickupstation.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case pickupstation.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case pickupstation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pickupstation.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	}
	return fmt.Errorf("unknown PickupStation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PickupStationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PickupStationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PickupStationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PickupStation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PickupStationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PickupStationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PickupStationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PickupStation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PickupStationMutation) ResetField(name string) error {
	switch name {
	case pickupstation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pickupstation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pickupstation.FieldRegion:
		m.ResetRegion()
		return nil
	case pickupstation.FieldCity:
		m.ResetCity()
		return nil
	case pickupstation.FieldName:
		m.ResetName()
		return nil
	case pickupstation.FieldAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown PickupStation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PickupStationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.orders != nil {
		edges = append(edges, pickupstation.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PickupStationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pickupstation.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PickupStationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorders != nil {
		edges = append(edges, pickupstation.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PickupStationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pickupstation.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PickupStationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorders {
		edges = append(edges, pickupstation.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PickupStationMutation) EdgeCleared(name string) bool {
	switch name {
	case pickupstation.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PickupStationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PickupStation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PickupStationMutation) ResetEdge(name string) error {
	switch name {
	case pickupstation.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown PickupStation edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	price                *float64
	addprice             *float64
	promo_price          *float64
	addpromo_price       *float64
	weight               *uint32
	addweight            *int32
	quantity             *uint32
	addquantity          *int32
	unit                 *string
	description          *string
	image                *string
	clearedFields        map[string]struct{}
	order_details        map[int]struct{}
	removedorder_details map[int]struct{}
	clearedorder_details bool
	favourites           map[int]struct{}
	removedfavourites    map[int]struct{}
	clearedfavourites    bool
	merchant             *int
	clearedmerchant      bool
	major                *int
	clearedmajor         bool
	minor                *int
	clearedminor         bool
	done                 bool
	oldValue             func(context.Context) (*Product, error)
	predicates           []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetPromoPrice sets the "promo_price" field.
func (m *ProductMutation) SetPromoPrice(f float64) {
	m.promo_price = &f
	m.addpromo_price = nil
}

// PromoPrice returns the value of the "promo_price" field in the mutation.
func (m *ProductMutation) PromoPrice() (r float64, exists bool) {
	v := m.promo_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPromoPrice returns the old "promo_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPromoPrice(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromoPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromoPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromoPrice: %w", err)
	}
	return oldValue.PromoPrice, nil
}

// AddPromoPrice adds f to the "promo_price" field.
func (m *ProductMutation) AddPromoPrice(f float64) {
	if m.addpromo_price != nil {
		*m.addpromo_price += f
	} else {
		m.addpromo_price = &f
	}
}

// AddedPromoPrice returns the value that was added to the "promo_price" field in this mutation.
func (m *ProductMutation) AddedPromoPrice() (r float64, exists bool) {
	v := m.addpromo_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromoPrice clears the value of the "promo_price" field.
func (m *ProductMutation) ClearPromoPrice() {
	m.promo_price = nil
	m.addpromo_price = nil
	m.clearedFields[product.FieldPromoPrice] = struct{}{}
}

// PromoPriceCleared returns if the "promo_price" field was cleared in this mutation.
func (m *ProductMutation) PromoPriceCleared() bool {
	_, ok := m.clearedFields[product.FieldPromoPrice]
	return ok
}

// ResetPromoPrice resets all changes to the "promo_price" field.
func (m *ProductMutation) ResetPromoPrice() {
	m.promo_price = nil
	m.addpromo_price = nil
	delete(m.clearedFields, product.FieldPromoPrice)
}

// SetWeight sets the "weight" field.
func (m *ProductMutation) SetWeight(u uint32) {
	m.weight = &u
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *ProductMutation) Weight() (r uint32, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldWeight(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds u to the "weight" field.
func (m *ProductMutation) AddWeight(u int32) {
	if m.addweight != nil {
		*m.addweight += u
	} else {
		m.addweight = &u
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *ProductMutation) AddedWeight() (r int32, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *ProductMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetQuantity sets the "quantity" field.
func (m *ProductMutation) SetQuantity(u uint32) {
	m.quantity = &u
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ProductMutation) Quantity() (r uint32, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldQuantity(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds u to the "quantity" field.
func (m *ProductMutation) AddQuantity(u int32) {
	if m.addquantity != nil {
		*m.addquantity += u
	} else {
		m.addquantity = &u
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ProductMutation) AddedQuantity() (r int32, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ProductMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnit sets the "unit" field.
func (m *ProductMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *ProductMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *ProductMutation) ResetUnit() {
	m.unit = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
}

// SetImage sets the "image" field.
func (m *ProductMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ProductMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *ProductMutation) ResetImage() {
	m.image = nil
}

// AddOrderDetailIDs adds the "order_details" edge to the OrderDetail entity by ids.
func (m *ProductMutation) AddOrderDetailIDs(ids ...int) {
	if m.order_details == nil {
		m.order_details = make(map[int]struct{})
	}
	for i := range ids {
		m.order_details[ids[i]] = struct{}{}
	}
}

// ClearOrderDetails clears the "order_details" edge to the OrderDetail entity.
func (m *ProductMutation) ClearOrderDetails() {
	m.clearedorder_details = true
}

// OrderDetailsCleared reports if the "order_details" edge to the OrderDetail entity was cleared.
func (m *ProductMutation) OrderDetailsCleared() bool {
	return m.clearedorder_details
}

// RemoveOrderDetailIDs removes the "order_details" edge to the OrderDetail entity by IDs.
func (m *ProductMutation) RemoveOrderDetailIDs(ids ...int) {
	if m.removedorder_details == nil {
		m.removedorder_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_details, ids[i])
		m.removedorder_details[ids[i]] = struct{}{}
	}
}

// RemovedOrderDetails returns the removed IDs of the "order_details" edge to the OrderDetail entity.
func (m *ProductMutation) RemovedOrderDetailsIDs() (ids []int) {
	for id := range m.removedorder_details {
		ids = append(ids, id)
	}
	return
}

// OrderDetailsIDs returns the "order_details" edge IDs in the mutation.
func (m *ProductMutation) OrderDetailsIDs() (ids []int) {
	for id := range m.order_details {
		ids = append(ids, id)
	}
	return
}

// ResetOrderDetails resets all changes to the "order_details" edge.
func (m *ProductMutation) ResetOrderDetails() {
	m.order_details = nil
	m.clearedorder_details = false
	m.removedorder_details = nil
}

// AddFavouriteIDs adds the "favourites" edge to the Favourite entity by ids.
func (m *ProductMutation) AddFavouriteIDs(ids ...int) {
	if m.favourites == nil {
		m.favourites = make(map[int]struct{})
	}
	for i := range ids {
		m.favourites[ids[i]] = struct{}{}
	}
}

// ClearFavourites clears the "favourites" edge to the Favourite entity.
func (m *ProductMutation) ClearFavourites() {
	m.clearedfavourites = true
}

// FavouritesCleared reports if the "favourites" edge to the Favourite entity was cleared.
func (m *ProductMutation) FavouritesCleared() bool {
	return m.clearedfavourites
}

// RemoveFavouriteIDs removes the "favourites" edge to the Favourite entity by IDs.
func (m *ProductMutation) RemoveFavouriteIDs(ids ...int) {
	if m.removedfavourites == nil {
		m.removedfavourites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favourites, ids[i])
		m.removedfavourites[ids[i]] = struct{}{}
	}
}

// RemovedFavourites returns the removed IDs of the "favourites" edge to the Favourite entity.
func (m *ProductMutation) RemovedFavouritesIDs() (ids []int) {
	for id := range m.removedfavourites {
		ids = append(ids, id)
	}
	return
}

// FavouritesIDs returns the "favourites" edge IDs in the mutation.
func (m *ProductMutation) FavouritesIDs() (ids []int) {
	for id := range m.favourites {
		ids = append(ids, id)
	}
	return
}

// ResetFavourites resets all changes to the "favourites" edge.
func (m *ProductMutation) ResetFavourites() {
	m.favourites = nil
	m.clearedfavourites = false
	m.removedfavourites = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *ProductMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *ProductMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *ProductMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *ProductMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *ProductMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetMajorID sets the "major" edge to the ProductCategoryMajor entity by id.
func (m *ProductMutation) SetMajorID(id int) {
	m.major = &id
}

// ClearMajor clears the "major" edge to the ProductCategoryMajor entity.
func (m *ProductMutation) ClearMajor() {
	m.clearedmajor = true
}

// MajorCleared reports if the "major" edge to the ProductCategoryMajor entity was cleared.
func (m *ProductMutation) MajorCleared() bool {
	return m.clearedmajor
}

// MajorID returns the "major" edge ID in the mutation.
func (m *ProductMutation) MajorID() (id int, exists bool) {
	if m.major != nil {
		return *m.major, true
	}
	return
}

// MajorIDs returns the "major" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) MajorIDs() (ids []int) {
	if id := m.major; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajor resets all changes to the "major" edge.
func (m *ProductMutation) ResetMajor() {
	m.major = nil
	m.clearedmajor = false
}

// SetMinorID sets the "minor" edge to the ProductCategoryMinor entity by id.
func (m *ProductMutation) SetMinorID(id int) {
	m.minor = &id
}

// ClearMinor clears the "minor" edge to the ProductCategoryMinor entity.
func (m *ProductMutation) ClearMinor() {
	m.clearedminor = true
}

// MinorCleared reports if the "minor" edge to the ProductCategoryMinor entity was cleared.
func (m *ProductMutation) MinorCleared() bool {
	return m.clearedminor
}

// MinorID returns the "minor" edge ID in the mutation.
func (m *ProductMutation) MinorID() (id int, exists bool) {
	if m.minor != nil {
		return *m.minor, true
	}
	return
}

// MinorIDs returns the "minor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MinorID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) MinorIDs() (ids []int) {
	if id := m.minor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMinor resets all changes to the "minor" edge.
func (m *ProductMutation) ResetMinor() {
	m.minor = nil
	m.clearedminor = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.promo_price != nil {
		fields = append(fields, product.FieldPromoPrice)
	}
	if m.weight != nil {
		fields = append(fields, product.FieldWeight)
	}
	if m.quantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	if m.unit != nil {
		fields = append(fields, product.FieldUnit)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.image != nil {
		fields = append(fields, product.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldName:
		return m.Name()
	case product.FieldPrice:
		return m.Price()
	case product.FieldPromoPrice:
		return m.PromoPrice()
	case product.FieldWeight:
		return m.Weight()
	case product.FieldQuantity:
		return m.Quantity()
	case product.FieldUnit:
		return m.Unit()
	case product.FieldDescription:
		return m.Description()
	case product.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldPromoPrice:
		return m.OldPromoPrice(ctx)
	case product.FieldWeight:
		return m.OldWeight(ctx)
	case product.FieldQuantity:
		return m.OldQuantity(ctx)
	case product.FieldUnit:
		return m.OldUnit(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldPromoPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromoPrice(v)
		return nil
	case product.FieldWeight:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case product.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.addpromo_price != nil {
		fields = append(fields, product.FieldPromoPrice)
	}
	if m.addweight != nil {
		fields = append(fields, product.FieldWeight)
	}
	if m.addquantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldPrice:
		return m.AddedPrice()
	case product.FieldPromoPrice:
		return m.AddedPromoPrice()
	case product.FieldWeight:
		return m.AddedWeight()
	case product.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case product.FieldPromoPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromoPrice(v)
		return nil
	case product.FieldWeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldPromoPrice) {
		fields = append(fields, product.FieldPromoPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldPromoPrice:
		m.ClearPromoPrice()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldPromoPrice:
		m.ResetPromoPrice()
		return nil
	case product.FieldWeight:
		m.ResetWeight()
		return nil
	case product.FieldQuantity:
		m.ResetQuantity()
		return nil
	case product.FieldUnit:
		m.ResetUnit()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.order_details != nil {
		edges = append(edges, product.EdgeOrderDetails)
	}
	if m.favourites != nil {
		edges = append(edges, product.EdgeFavourites)
	}
	if m.merchant != nil {
		edges = append(edges, product.EdgeMerchant)
	}
	if m.major != nil {
		edges = append(edges, product.EdgeMajor)
	}
	if m.minor != nil {
		edges = append(edges, product.EdgeMinor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeOrderDetails:
		ids := make([]ent.Value, 0, len(m.order_details))
		for id := range m.order_details {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.favourites))
		for id := range m.favourites {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeMajor:
		if id := m.major; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeMinor:
		if id := m.minor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedorder_details != nil {
		edges = append(edges, product.EdgeOrderDetails)
	}
	if m.removedfavourites != nil {
		edges = append(edges, product.EdgeFavourites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeOrderDetails:
		ids := make([]ent.Value, 0, len(m.removedorder_details))
		for id := range m.removedorder_details {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.removedfavourites))
		for id := range m.removedfavourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedorder_details {
		edges = append(edges, product.EdgeOrderDetails)
	}
	if m.clearedfavourites {
		edges = append(edges, product.EdgeFavourites)
	}
	if m.clearedmerchant {
		edges = append(edges, product.EdgeMerchant)
	}
	if m.clearedmajor {
		edges = append(edges, product.EdgeMajor)
	}
	if m.clearedminor {
		edges = append(edges, product.EdgeMinor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeOrderDetails:
		return m.clearedorder_details
	case product.EdgeFavourites:
		return m.clearedfavourites
	case product.EdgeMerchant:
		return m.clearedmerchant
	case product.EdgeMajor:
		return m.clearedmajor
	case product.EdgeMinor:
		return m.clearedminor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case product.EdgeMajor:
		m.ClearMajor()
		return nil
	case product.EdgeMinor:
		m.ClearMinor()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeOrderDetails:
		m.ResetOrderDetails()
		return nil
	case product.EdgeFavourites:
		m.ResetFavourites()
		return nil
	case product.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case product.EdgeMajor:
		m.ResetMajor()
		return nil
	case product.EdgeMinor:
		m.ResetMinor()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductCategoryMajorMutation represents an operation that mutates the ProductCategoryMajor nodes in the graph.
type ProductCategoryMajorMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	category        *string
	slug            *string
	clearedFields   map[string]struct{}
	minors          map[int]struct{}
	removedminors   map[int]struct{}
	clearedminors   bool
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*ProductCategoryMajor, error)
	predicates      []predicate.ProductCategoryMajor
}

var _ ent.Mutation = (*ProductCategoryMajorMutation)(nil)

// productcategorymajorOption allows management of the mutation configuration using functional options.
type productcategorymajorOption func(*ProductCategoryMajorMutation)

// newProductCategoryMajorMutation creates new mutation for the ProductCategoryMajor entity.
func newProductCategoryMajorMutation(c config, op Op, opts ...productcategorymajorOption) *ProductCategoryMajorMutation {
	m := &ProductCategoryMajorMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategoryMajor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryMajorID sets the ID field of the mutation.
func withProductCategoryMajorID(id int) productcategorymajorOption {
	return func(m *ProductCategoryMajorMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategoryMajor
		)
		m.oldValue = func(ctx context.Context) (*ProductCategoryMajor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategoryMajor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategoryMajor sets the old ProductCategoryMajor of the mutation.
func withProductCategoryMajor(node *ProductCategoryMajor) productcategorymajorOption {
	return func(m *ProductCategoryMajorMutation) {
		m.oldValue = func(context.Context) (*ProductCategoryMajor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryMajorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryMajorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCategoryMajorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductCategoryMajorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductCategoryMajor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductCategoryMajorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductCategoryMajorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductCategoryMajor entity.
// If the ProductCategoryMajor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMajorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductCategoryMajorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductCategoryMajorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductCategoryMajorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductCategoryMajor entity.
// If the ProductCategoryMajor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMajorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductCategoryMajorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCategory sets the "category" field.
func (m *ProductCategoryMajorMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProductCategoryMajorMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ProductCategoryMajor entity.
// If the ProductCategoryMajor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMajorMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ProductCategoryMajorMutation) ResetCategory() {
	m.category = nil
}

// SetSlug sets the "slug" field.
func (m *ProductCategoryMajorMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ProductCategoryMajorMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the ProductCategoryMajor entity.
// If the ProductCategoryMajor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMajorMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ProductCategoryMajorMutation) ResetSlug() {
	m.slug = nil
}

// AddMinorIDs adds the "minors" edge to the ProductCategoryMinor entity by ids.
func (m *ProductCategoryMajorMutation) AddMinorIDs(ids ...int) {
	if m.minors == nil {
		m.minors = make(map[int]struct{})
	}
	for i := range ids {
		m.minors[ids[i]] = struct{}{}
	}
}

// ClearMinors clears the "minors" edge to the ProductCategoryMinor entity.
func (m *ProductCategoryMajorMutation) ClearMinors() {
	m.clearedminors = true
}

// MinorsCleared reports if the "minors" edge to the ProductCategoryMinor entity was cleared.
func (m *ProductCategoryMajorMutation) MinorsCleared() bool {
	return m.clearedminors
}

// RemoveMinorIDs removes the "minors" edge to the ProductCategoryMinor entity by IDs.
func (m *ProductCategoryMajorMutation) RemoveMinorIDs(ids ...int) {
	if m.removedminors == nil {
		m.removedminors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.minors, ids[i])
		m.removedminors[ids[i]] = struct{}{}
	}
}

// RemovedMinors returns the removed IDs of the "minors" edge to the ProductCategoryMinor entity.
func (m *ProductCategoryMajorMutation) RemovedMinorsIDs() (ids []int) {
	for id := range m.removedminors {
		ids = append(ids, id)
	}
	return
}

// MinorsIDs returns the "minors" edge IDs in the mutation.
func (m *ProductCategoryMajorMutation) MinorsIDs() (ids []int) {
	for id := range m.minors {
		ids = append(ids, id)
	}
	return
}

// ResetMinors resets all changes to the "minors" edge.
func (m *ProductCategoryMajorMutation) ResetMinors() {
	m.minors = nil
	m.clearedminors = false
	m.removedminors = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ProductCategoryMajorMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductCategoryMajorMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductCategoryMajorMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ProductCategoryMajorMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ProductCategoryMajorMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductCategoryMajorMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductCategoryMajorMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ProductCategoryMajorMutation builder.
func (m *ProductCategoryMajorMutation) Where(ps ...predicate.ProductCategoryMajor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductCategoryMajorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductCategoryMajor).
func (m *ProductCategoryMajorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryMajorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, productcategorymajor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productcategorymajor.FieldUpdatedAt)
	}
	if m.category != nil {
		fields = append(fields, productcategorymajor.FieldCategory)
	}
	if m.slug != nil {
		fields = append(fields, productcategorymajor.FieldSlug)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryMajorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategorymajor.FieldCreatedAt:
		return m.CreatedAt()
	case productcategorymajor.FieldUpdatedAt:
		return m.UpdatedAt()
	case productcategorymajor.FieldCategory:
		return m.Category()
	case productcategorymajor.FieldSlug:
		return m.Slug()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryMajorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategorymajor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productcategorymajor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productcategorymajor.FieldCategory:
		return m.OldCategory(ctx)
	case productcategorymajor.FieldSlug:
		return m.OldSlug(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategoryMajor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMajorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategorymajor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productcategorymajor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productcategorymajor.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case productcategorymajor.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMajor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryMajorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryMajorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMajorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategoryMajor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryMajorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryMajorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryMajorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductCategoryMajor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryMajorMutation) ResetField(name string) error {
	switch name {
	case productcategorymajor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productcategorymajor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productcategorymajor.FieldCategory:
		m.ResetCategory()
		return nil
	case productcategorymajor.FieldSlug:
		m.ResetSlug()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMajor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryMajorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.minors != nil {
		edges = append(edges, productcategorymajor.EdgeMinors)
	}
	if m.products != nil {
		edges = append(edges, productcategorymajor.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryMajorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcategorymajor.EdgeMinors:
		ids := make([]ent.Value, 0, len(m.minors))
		for id := range m.minors {
			ids = append(ids, id)
		}
		return ids
	case productcategorymajor.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryMajorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedminors != nil {
		edges = append(edges, productcategorymajor.EdgeMinors)
	}
	if m.removedproducts != nil {
		edges = append(edges, productcategorymajor.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryMajorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcategorymajor.EdgeMinors:
		ids := make([]ent.Value, 0, len(m.removedminors))
		for id := range m.removedminors {
			ids = append(ids, id)
		}
		return ids
	case productcategorymajor.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryMajorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedminors {
		edges = append(edges, productcategorymajor.EdgeMinors)
	}
	if m.clearedproducts {
		edges = append(edges, productcategorymajor.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryMajorMutation) EdgeCleared(name string) bool {
	switch name {
	case productcategorymajor.EdgeMinors:
		return m.clearedminors
	case productcategorymajor.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryMajorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategoryMajor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryMajorMutation) ResetEdge(name string) error {
	switch name {
	case productcategorymajor.EdgeMinors:
		m.ResetMinors()
		return nil
	case productcategorymajor.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMajor edge %s", name)
}

// ProductCategoryMinorMutation represents an operation that mutates the ProductCategoryMinor nodes in the graph.
type ProductCategoryMinorMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	category        *string
	image           *string
	slug            *string
	clearedFields   map[string]struct{}
	major           *int
	clearedmajor    bool
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*ProductCategoryMinor, error)
	predicates      []predicate.ProductCategoryMinor
}

var _ ent.Mutation = (*ProductCategoryMinorMutation)(nil)

// productcategoryminorOption allows management of the mutation configuration using functional options.
type productcategoryminorOption func(*ProductCategoryMinorMutation)

// newProductCategoryMinorMutation creates new mutation for the ProductCategoryMinor entity.
func newProductCategoryMinorMutation(c config, op Op, opts ...productcategoryminorOption) *ProductCategoryMinorMutation {
	m := &ProductCategoryMinorMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategoryMinor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryMinorID sets the ID field of the mutation.
func withProductCategoryMinorID(id int) productcategoryminorOption {
	return func(m *ProductCategoryMinorMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategoryMinor
		)
		m.oldValue = func(ctx context.Context) (*ProductCategoryMinor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategoryMinor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategoryMinor sets the old ProductCategoryMinor of the mutation.
func withProductCategoryMinor(node *ProductCategoryMinor) productcategoryminorOption {
	return func(m *ProductCategoryMinorMutation) {
		m.oldValue = func(context.Context) (*ProductCategoryMinor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryMinorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryMinorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCategoryMinorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductCategoryMinorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductCategoryMinor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductCategoryMinorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductCategoryMinorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductCategoryMinor entity.
// If the ProductCategoryMinor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMinorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductCategoryMinorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductCategoryMinorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductCategoryMinorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductCategoryMinor entity.
// If the ProductCategoryMinor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMinorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductCategoryMinorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCategory sets the "category" field.
func (m *ProductCategoryMinorMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProductCategoryMinorMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ProductCategoryMinor entity.
// If the ProductCategoryMinor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMinorMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ProductCategoryMinorMutation) ResetCategory() {
	m.category = nil
}

// SetImage sets the "image" field.
func (m *ProductCategoryMinorMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ProductCategoryMinorMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the ProductCategoryMinor entity.
// If the ProductCategoryMinor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMinorMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *ProductCategoryMinorMutation) ResetImage() {
	m.image = nil
}

// SetSlug sets the "slug" field.
func (m *ProductCategoryMinorMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ProductCategoryMinorMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the ProductCategoryMinor entity.
// If the ProductCategoryMinor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMinorMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ProductCategoryMinorMutation) ResetSlug() {
	m.slug = nil
}

// SetMajorID sets the "major" edge to the ProductCategoryMajor entity by id.
func (m *ProductCategoryMinorMutation) SetMajorID(id int) {
	m.major = &id
}

// ClearMajor clears the "major" edge to the ProductCategoryMajor entity.
func (m *ProductCategoryMinorMutation) ClearMajor() {
	m.clearedmajor = true
}

// MajorCleared reports if the "major" edge to the ProductCategoryMajor entity was cleared.
func (m *ProductCategoryMinorMutation) MajorCleared() bool {
	return m.clearedmajor
}

// MajorID returns the "major" edge ID in the mutation.
func (m *ProductCategoryMinorMutation) MajorID() (id int, exists bool) {
	if m.major != nil {
		return *m.major, true
	}
	return
}

// MajorIDs returns the "major" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorID instead. It exists only for internal usage by the builders.
func (m *ProductCategoryMinorMutation) MajorIDs() (ids []int) {
	if id := m.major; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajor resets all changes to the "major" edge.
func (m *ProductCategoryMinorMutation) ResetMajor() {
	m.major = nil
	m.clearedmajor = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ProductCategoryMinorMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductCategoryMinorMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductCategoryMinorMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ProductCategoryMinorMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ProductCategoryMinorMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductCategoryMinorMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductCategoryMinorMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ProductCategoryMinorMutation builder.
func (m *ProductCategoryMinorMutation) Where(ps ...predicate.ProductCategoryMinor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductCategoryMinorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductCategoryMinor).
func (m *ProductCategoryMinorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryMinorMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, productcategoryminor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productcategoryminor.FieldUpdatedAt)
	}
	if m.category != nil {
		fields = append(fields, productcategoryminor.FieldCategory)
	}
	if m.image != nil {
		fields = append(fields, productcategoryminor.FieldImage)
	}
	if m.slug != nil {
		fields = append(fields, productcategoryminor.FieldSlug)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryMinorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategoryminor.FieldCreatedAt:
		return m.CreatedAt()
	case productcategoryminor.FieldUpdatedAt:
		return m.UpdatedAt()
	case productcategoryminor.FieldCategory:
		return m.Category()
	case productcategoryminor.FieldImage:
		return m.Image()
	case productcategoryminor.FieldSlug:
		return m.Slug()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryMinorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategoryminor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productcategoryminor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productcategoryminor.FieldCategory:
		return m.OldCategory(ctx)
	case productcategoryminor.FieldImage:
		return m.OldImage(ctx)
	case productcategoryminor.FieldSlug:
		return m.OldSlug(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategoryMinor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMinorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategoryminor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productcategoryminor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productcategoryminor.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case productcategoryminor.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case productcategoryminor.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMinor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryMinorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryMinorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMinorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategoryMinor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryMinorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryMinorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryMinorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductCategoryMinor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryMinorMutation) ResetField(name string) error {
	switch name {
	case productcategoryminor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productcategoryminor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productcategoryminor.FieldCategory:
		m.ResetCategory()
		return nil
	case productcategoryminor.FieldImage:
		m.ResetImage()
		return nil
	case productcategoryminor.FieldSlug:
		m.ResetSlug()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMinor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryMinorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.major != nil {
		edges = append(edges, productcategoryminor.EdgeMajor)
	}
	if m.products != nil {
		edges = append(edges, productcategoryminor.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryMinorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcategoryminor.EdgeMajor:
		if id := m.major; id != nil {
			return []ent.Value{*id}
		}
	case productcategoryminor.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryMinorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproducts != nil {
		edges = append(edges, productcategoryminor.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryMinorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcategoryminor.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryMinorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmajor {
		edges = append(edges, productcategoryminor.EdgeMajor)
	}
	if m.clearedproducts {
		edges = append(edges, productcategoryminor.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryMinorMutation) EdgeCleared(name string) bool {
	switch name {
	case productcategoryminor.EdgeMajor:
		return m.clearedmajor
	case productcategoryminor.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryMinorMutation) ClearEdge(name string) error {
	switch name {
	case productcategoryminor.EdgeMajor:
		m.ClearMajor()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMinor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryMinorMutation) ResetEdge(name string) error {
	switch name {
	case productcategoryminor.EdgeMajor:
		m.ResetMajor()
		return nil
	case productcategoryminor.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMinor edge %s", name)
}

// RetailMerchantMutation represents an operation that mutates the RetailMerchant nodes in the graph.
type RetailMerchantMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	ghana_card      *string
	last_name       *string
	other_name      *string
	phone           *string
	other_phone     *string
	address         *string
	digital_address *string
	clearedFields   map[string]struct{}
	merchant        *int
	clearedmerchant bool
	done            bool
	oldValue        func(context.Context) (*RetailMerchant, error)
	predicates      []predicate.RetailMerchant
}

var _ ent.Mutation = (*RetailMerchantMutation)(nil)

// retailmerchantOption allows management of the mutation configuration using functional options.
type retailmerchantOption func(*RetailMerchantMutation)

// newRetailMerchantMutation creates new mutation for the RetailMerchant entity.
func newRetailMerchantMutation(c config, op Op, opts ...retailmerchantOption) *RetailMerchantMutation {
	m := &RetailMerchantMutation{
		config:        c,
		op:            op,
		typ:           TypeRetailMerchant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRetailMerchantID sets the ID field of the mutation.
func withRetailMerchantID(id int) retailmerchantOption {
	return func(m *RetailMerchantMutation) {
		var (
			err   error
			once  sync.Once
			value *RetailMerchant
		)
		m.oldValue = func(ctx context.Context) (*RetailMerchant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RetailMerchant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRetailMerchant sets the old RetailMerchant of the mutation.
func withRetailMerchant(node *RetailMerchant) retailmerchantOption {
	return func(m *RetailMerchantMutation) {
		m.oldValue = func(context.Context) (*RetailMerchant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RetailMerchantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RetailMerchantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RetailMerchantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RetailMerchantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RetailMerchant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RetailMerchantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RetailMerchantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RetailMerchantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RetailMerchantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RetailMerchantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RetailMerchantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGhanaCard sets the "ghana_card" field.
func (m *RetailMerchantMutation) SetGhanaCard(s string) {
	m.ghana_card = &s
}

// GhanaCard returns the value of the "ghana_card" field in the mutation.
func (m *RetailMerchantMutation) GhanaCard() (r string, exists bool) {
	v := m.ghana_card
	if v == nil {
		return
	}
	return *v, true
}

// OldGhanaCard returns the old "ghana_card" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldGhanaCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGhanaCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGhanaCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGhanaCard: %w", err)
	}
	return oldValue.GhanaCard, nil
}

// ResetGhanaCard resets all changes to the "ghana_card" field.
func (m *RetailMerchantMutation) ResetGhanaCard() {
	m.ghana_card = nil
}

// SetLastName sets the "last_name" field.
func (m *RetailMerchantMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *RetailMerchantMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *RetailMerchantMutation) ResetLastName() {
	m.last_name = nil
}

// SetOtherName sets the "other_name" field.
func (m *RetailMerchantMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *RetailMerchantMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *RetailMerchantMutation) ResetOtherName() {
	m.other_name = nil
}

// SetPhone sets the "phone" field.
func (m *RetailMerchantMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *RetailMerchantMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *RetailMerchantMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *RetailMerchantMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *RetailMerchantMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldOtherPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *RetailMerchantMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[retailmerchant.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *RetailMerchantMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[retailmerchant.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *RetailMerchantMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, retailmerchant.FieldOtherPhone)
}

// SetAddress sets the "address" field.
func (m *RetailMerchantMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *RetailMerchantMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *RetailMerchantMutation) ResetAddress() {
	m.address = nil
}

// SetDigitalAddress sets the "digital_address" field.
func (m *RetailMerchantMutation) SetDigitalAddress(s string) {
	m.digital_address = &s
}

// DigitalAddress returns the value of the "digital_address" field in the mutation.
func (m *RetailMerchantMutation) DigitalAddress() (r string, exists bool) {
	v := m.digital_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDigitalAddress returns the old "digital_address" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldDigitalAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigitalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigitalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigitalAddress: %w", err)
	}
	return oldValue.DigitalAddress, nil
}

// ResetDigitalAddress resets all changes to the "digital_address" field.
func (m *RetailMerchantMutation) ResetDigitalAddress() {
	m.digital_address = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *RetailMerchantMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *RetailMerchantMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *RetailMerchantMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *RetailMerchantMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *RetailMerchantMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *RetailMerchantMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// Where appends a list predicates to the RetailMerchantMutation builder.
func (m *RetailMerchantMutation) Where(ps ...predicate.RetailMerchant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RetailMerchantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RetailMerchant).
func (m *RetailMerchantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RetailMerchantMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, retailmerchant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, retailmerchant.FieldUpdatedAt)
	}
	if m.ghana_card != nil {
		fields = append(fields, retailmerchant.FieldGhanaCard)
	}
	if m.last_name != nil {
		fields = append(fields, retailmerchant.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, retailmerchant.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, retailmerchant.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, retailmerchant.FieldOtherPhone)
	}
	if m.address != nil {
		fields = append(fields, retailmerchant.FieldAddress)
	}
	if m.digital_address != nil {
		fields = append(fields, retailmerchant.FieldDigitalAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RetailMerchantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case retailmerchant.FieldCreatedAt:
		return m.CreatedAt()
	case retailmerchant.FieldUpdatedAt:
		return m.UpdatedAt()
	case retailmerchant.FieldGhanaCard:
		return m.GhanaCard()
	case retailmerchant.FieldLastName:
		return m.LastName()
	case retailmerchant.FieldOtherName:
		return m.OtherName()
	case retailmerchant.FieldPhone:
		return m.Phone()
	case retailmerchant.FieldOtherPhone:
		return m.OtherPhone()
	case retailmerchant.FieldAddress:
		return m.Address()
	case retailmerchant.FieldDigitalAddress:
		return m.DigitalAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RetailMerchantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case retailmerchant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case retailmerchant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case retailmerchant.FieldGhanaCard:
		return m.OldGhanaCard(ctx)
	case retailmerchant.FieldLastName:
		return m.OldLastName(ctx)
	case retailmerchant.FieldOtherName:
		return m.OldOtherName(ctx)
	case retailmerchant.FieldPhone:
		return m.OldPhone(ctx)
	case retailmerchant.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case retailmerchant.FieldAddress:
		return m.OldAddress(ctx)
	case retailmerchant.FieldDigitalAddress:
		return m.OldDigitalAddress(ctx)
	}
	return nil, fmt.Errorf("unknown RetailMerchant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetailMerchantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case retailmerchant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case retailmerchant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case retailmerchant.FieldGhanaCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGhanaCard(v)
		return nil
	case retailmerchant.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case retailmerchant.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case retailmerchant.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case retailmerchant.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case retailmerchant.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case retailmerchant.FieldDigitalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigitalAddress(v)
		return nil
	}
	return fmt.Errorf("unknown RetailMerchant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RetailMerchantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RetailMerchantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetailMerchantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RetailMerchant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RetailMerchantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(retailmerchant.FieldOtherPhone) {
		fields = append(fields, retailmerchant.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RetailMerchantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RetailMerchantMutation) ClearField(name string) error {
	switch name {
	case retailmerchant.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown RetailMerchant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RetailMerchantMutation) ResetField(name string) error {
	switch name {
	case retailmerchant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case retailmerchant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case retailmerchant.FieldGhanaCard:
		m.ResetGhanaCard()
		return nil
	case retailmerchant.FieldLastName:
		m.ResetLastName()
		return nil
	case retailmerchant.FieldOtherName:
		m.ResetOtherName()
		return nil
	case retailmerchant.FieldPhone:
		m.ResetPhone()
		return nil
	case retailmerchant.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case retailmerchant.FieldAddress:
		m.ResetAddress()
		return nil
	case retailmerchant.FieldDigitalAddress:
		m.ResetDigitalAddress()
		return nil
	}
	return fmt.Errorf("unknown RetailMerchant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RetailMerchantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.merchant != nil {
		edges = append(edges, retailmerchant.EdgeMerchant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RetailMerchantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case retailmerchant.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RetailMerchantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RetailMerchantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RetailMerchantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmerchant {
		edges = append(edges, retailmerchant.EdgeMerchant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RetailMerchantMutation) EdgeCleared(name string) bool {
	switch name {
	case retailmerchant.EdgeMerchant:
		return m.clearedmerchant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RetailMerchantMutation) ClearEdge(name string) error {
	switch name {
	case retailmerchant.EdgeMerchant:
		m.ClearMerchant()
		return nil
	}
	return fmt.Errorf("unknown RetailMerchant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RetailMerchantMutation) ResetEdge(name string) error {
	switch name {
	case retailmerchant.EdgeMerchant:
		m.ResetMerchant()
		return nil
	}
	return fmt.Errorf("unknown RetailMerchant edge %s", name)
}

// SupplierMerchantMutation represents an operation that mutates the SupplierMerchant nodes in the graph.
type SupplierMerchantMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	ghana_card      *string
	last_name       *string
	other_name      *string
	phone           *string
	other_phone     *string
	address         *string
	digital_address *string
	clearedFields   map[string]struct{}
	merchant        *int
	clearedmerchant bool
	done            bool
	oldValue        func(context.Context) (*SupplierMerchant, error)
	predicates      []predicate.SupplierMerchant
}

var _ ent.Mutation = (*SupplierMerchantMutation)(nil)

// suppliermerchantOption allows management of the mutation configuration using functional options.
type suppliermerchantOption func(*SupplierMerchantMutation)

// newSupplierMerchantMutation creates new mutation for the SupplierMerchant entity.
func newSupplierMerchantMutation(c config, op Op, opts ...suppliermerchantOption) *SupplierMerchantMutation {
	m := &SupplierMerchantMutation{
		config:        c,
		op:            op,
		typ:           TypeSupplierMerchant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSupplierMerchantID sets the ID field of the mutation.
func withSupplierMerchantID(id int) suppliermerchantOption {
	return func(m *SupplierMerchantMutation) {
		var (
			err   error
			once  sync.Once
			value *SupplierMerchant
		)
		m.oldValue = func(ctx context.Context) (*SupplierMerchant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SupplierMerchant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSupplierMerchant sets the old SupplierMerchant of the mutation.
func withSupplierMerchant(node *SupplierMerchant) suppliermerchantOption {
	return func(m *SupplierMerchantMutation) {
		m.oldValue = func(context.Context) (*SupplierMerchant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SupplierMerchantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SupplierMerchantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SupplierMerchantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SupplierMerchantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SupplierMerchant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SupplierMerchantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SupplierMerchantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SupplierMerchantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SupplierMerchantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SupplierMerchantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SupplierMerchantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGhanaCard sets the "ghana_card" field.
func (m *SupplierMerchantMutation) SetGhanaCard(s string) {
	m.ghana_card = &s
}

// GhanaCard returns the value of the "ghana_card" field in the mutation.
func (m *SupplierMerchantMutation) GhanaCard() (r string, exists bool) {
	v := m.ghana_card
	if v == nil {
		return
	}
	return *v, true
}

// OldGhanaCard returns the old "ghana_card" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldGhanaCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGhanaCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGhanaCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGhanaCard: %w", err)
	}
	return oldValue.GhanaCard, nil
}

// ResetGhanaCard resets all changes to the "ghana_card" field.
func (m *SupplierMerchantMutation) ResetGhanaCard() {
	m.ghana_card = nil
}

// SetLastName sets the "last_name" field.
func (m *SupplierMerchantMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *SupplierMerchantMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *SupplierMerchantMutation) ResetLastName() {
	m.last_name = nil
}

// SetOtherName sets the "other_name" field.
func (m *SupplierMerchantMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *SupplierMerchantMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *SupplierMerchantMutation) ResetOtherName() {
	m.other_name = nil
}

// SetPhone sets the "phone" field.
func (m *SupplierMerchantMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SupplierMerchantMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *SupplierMerchantMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *SupplierMerchantMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *SupplierMerchantMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldOtherPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *SupplierMerchantMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[suppliermerchant.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *SupplierMerchantMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[suppliermerchant.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *SupplierMerchantMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, suppliermerchant.FieldOtherPhone)
}

// SetAddress sets the "address" field.
func (m *SupplierMerchantMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *SupplierMerchantMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *SupplierMerchantMutation) ResetAddress() {
	m.address = nil
}

// SetDigitalAddress sets the "digital_address" field.
func (m *SupplierMerchantMutation) SetDigitalAddress(s string) {
	m.digital_address = &s
}

// DigitalAddress returns the value of the "digital_address" field in the mutation.
func (m *SupplierMerchantMutation) DigitalAddress() (r string, exists bool) {
	v := m.digital_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDigitalAddress returns the old "digital_address" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldDigitalAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigitalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigitalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigitalAddress: %w", err)
	}
	return oldValue.DigitalAddress, nil
}

// ResetDigitalAddress resets all changes to the "digital_address" field.
func (m *SupplierMerchantMutation) ResetDigitalAddress() {
	m.digital_address = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *SupplierMerchantMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *SupplierMerchantMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *SupplierMerchantMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *SupplierMerchantMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *SupplierMerchantMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *SupplierMerchantMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// Where appends a list predicates to the SupplierMerchantMutation builder.
func (m *SupplierMerchantMutation) Where(ps ...predicate.SupplierMerchant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SupplierMerchantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SupplierMerchant).
func (m *SupplierMerchantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SupplierMerchantMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, suppliermerchant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, suppliermerchant.FieldUpdatedAt)
	}
	if m.ghana_card != nil {
		fields = append(fields, suppliermerchant.FieldGhanaCard)
	}
	if m.last_name != nil {
		fields = append(fields, suppliermerchant.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, suppliermerchant.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, suppliermerchant.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, suppliermerchant.FieldOtherPhone)
	}
	if m.address != nil {
		fields = append(fields, suppliermerchant.FieldAddress)
	}
	if m.digital_address != nil {
		fields = append(fields, suppliermerchant.FieldDigitalAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SupplierMerchantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case suppliermerchant.FieldCreatedAt:
		return m.CreatedAt()
	case suppliermerchant.FieldUpdatedAt:
		return m.UpdatedAt()
	case suppliermerchant.FieldGhanaCard:
		return m.GhanaCard()
	case suppliermerchant.FieldLastName:
		return m.LastName()
	case suppliermerchant.FieldOtherName:
		return m.OtherName()
	case suppliermerchant.FieldPhone:
		return m.Phone()
	case suppliermerchant.FieldOtherPhone:
		return m.OtherPhone()
	case suppliermerchant.FieldAddress:
		return m.Address()
	case suppliermerchant.FieldDigitalAddress:
		return m.DigitalAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SupplierMerchantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case suppliermerchant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case suppliermerchant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case suppliermerchant.FieldGhanaCard:
		return m.OldGhanaCard(ctx)
	case suppliermerchant.FieldLastName:
		return m.OldLastName(ctx)
	case suppliermerchant.FieldOtherName:
		return m.OldOtherName(ctx)
	case suppliermerchant.FieldPhone:
		return m.OldPhone(ctx)
	case suppliermerchant.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case suppliermerchant.FieldAddress:
		return m.OldAddress(ctx)
	case suppliermerchant.FieldDigitalAddress:
		return m.OldDigitalAddress(ctx)
	}
	return nil, fmt.Errorf("unknown SupplierMerchant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMerchantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case suppliermerchant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case suppliermerchant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case suppliermerchant.FieldGhanaCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGhanaCard(v)
		return nil
	case suppliermerchant.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case suppliermerchant.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case suppliermerchant.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case suppliermerchant.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case suppliermerchant.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case suppliermerchant.FieldDigitalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigitalAddress(v)
		return nil
	}
	return fmt.Errorf("unknown SupplierMerchant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SupplierMerchantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SupplierMerchantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMerchantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SupplierMerchant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SupplierMerchantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(suppliermerchant.FieldOtherPhone) {
		fields = append(fields, suppliermerchant.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SupplierMerchantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SupplierMerchantMutation) ClearField(name string) error {
	switch name {
	case suppliermerchant.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown SupplierMerchant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SupplierMerchantMutation) ResetField(name string) error {
	switch name {
	case suppliermerchant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case suppliermerchant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case suppliermerchant.FieldGhanaCard:
		m.ResetGhanaCard()
		return nil
	case suppliermerchant.FieldLastName:
		m.ResetLastName()
		return nil
	case suppliermerchant.FieldOtherName:
		m.ResetOtherName()
		return nil
	case suppliermerchant.FieldPhone:
		m.ResetPhone()
		return nil
	case suppliermerchant.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case suppliermerchant.FieldAddress:
		m.ResetAddress()
		return nil
	case suppliermerchant.FieldDigitalAddress:
		m.ResetDigitalAddress()
		return nil
	}
	return fmt.Errorf("unknown SupplierMerchant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SupplierMerchantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.merchant != nil {
		edges = append(edges, suppliermerchant.EdgeMerchant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SupplierMerchantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case suppliermerchant.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SupplierMerchantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SupplierMerchantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SupplierMerchantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmerchant {
		edges = append(edges, suppliermerchant.EdgeMerchant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SupplierMerchantMutation) EdgeCleared(name string) bool {
	switch name {
	case suppliermerchant.EdgeMerchant:
		return m.clearedmerchant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SupplierMerchantMutation) ClearEdge(name string) error {
	switch name {
	case suppliermerchant.EdgeMerchant:
		m.ClearMerchant()
		return nil
	}
	return fmt.Errorf("unknown SupplierMerchant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SupplierMerchantMutation) ResetEdge(name string) error {
	switch name {
	case suppliermerchant.EdgeMerchant:
		m.ResetMerchant()
		return nil
	}
	return fmt.Errorf("unknown SupplierMerchant edge %s", name)
}
