// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/SeyramWood/app/domain/models"
	"github.com/SeyramWood/ent/address"
	"github.com/SeyramWood/ent/admin"
	"github.com/SeyramWood/ent/agent"
	"github.com/SeyramWood/ent/basket"
	"github.com/SeyramWood/ent/customer"
	"github.com/SeyramWood/ent/favourite"
	"github.com/SeyramWood/ent/merchant"
	"github.com/SeyramWood/ent/merchantstore"
	"github.com/SeyramWood/ent/order"
	"github.com/SeyramWood/ent/predicate"
	"github.com/SeyramWood/ent/product"
	"github.com/SeyramWood/ent/productcategorymajor"
	"github.com/SeyramWood/ent/productcategoryminor"
	"github.com/SeyramWood/ent/retailmerchant"
	"github.com/SeyramWood/ent/suppliermerchant"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddress              = "Address"
	TypeAdmin                = "Admin"
	TypeAgent                = "Agent"
	TypeBasket               = "Basket"
	TypeCustomer             = "Customer"
	TypeFavourite            = "Favourite"
	TypeMerchant             = "Merchant"
	TypeMerchantStore        = "MerchantStore"
	TypeOrder                = "Order"
	TypeProduct              = "Product"
	TypeProductCategoryMajor = "ProductCategoryMajor"
	TypeProductCategoryMinor = "ProductCategoryMinor"
	TypeRetailMerchant       = "RetailMerchant"
	TypeSupplierMerchant     = "SupplierMerchant"
)

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	last_name         *string
	other_name        *string
	phone             *string
	other_phone       *string
	digital_address   *string
	city              *string
	_Region           *string
	address           *string
	other_information *string
	_default          *bool
	clearedFields     map[string]struct{}
	merchant          *int
	clearedmerchant   bool
	agent             *int
	clearedagent      bool
	customer          *int
	clearedcustomer   bool
	orders            map[int]struct{}
	removedorders     map[int]struct{}
	clearedorders     bool
	done              bool
	oldValue          func(context.Context) (*Address, error)
	predicates        []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id int) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AddressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastName sets the "last_name" field.
func (m *AddressMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AddressMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AddressMutation) ResetLastName() {
	m.last_name = nil
}

// SetOtherName sets the "other_name" field.
func (m *AddressMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *AddressMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *AddressMutation) ResetOtherName() {
	m.other_name = nil
}

// SetPhone sets the "phone" field.
func (m *AddressMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AddressMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *AddressMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *AddressMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *AddressMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldOtherPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *AddressMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[address.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *AddressMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[address.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *AddressMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, address.FieldOtherPhone)
}

// SetDigitalAddress sets the "digital_address" field.
func (m *AddressMutation) SetDigitalAddress(s string) {
	m.digital_address = &s
}

// DigitalAddress returns the value of the "digital_address" field in the mutation.
func (m *AddressMutation) DigitalAddress() (r string, exists bool) {
	v := m.digital_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDigitalAddress returns the old "digital_address" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldDigitalAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigitalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigitalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigitalAddress: %w", err)
	}
	return oldValue.DigitalAddress, nil
}

// ClearDigitalAddress clears the value of the "digital_address" field.
func (m *AddressMutation) ClearDigitalAddress() {
	m.digital_address = nil
	m.clearedFields[address.FieldDigitalAddress] = struct{}{}
}

// DigitalAddressCleared returns if the "digital_address" field was cleared in this mutation.
func (m *AddressMutation) DigitalAddressCleared() bool {
	_, ok := m.clearedFields[address.FieldDigitalAddress]
	return ok
}

// ResetDigitalAddress resets all changes to the "digital_address" field.
func (m *AddressMutation) ResetDigitalAddress() {
	m.digital_address = nil
	delete(m.clearedFields, address.FieldDigitalAddress)
}

// SetCity sets the "city" field.
func (m *AddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AddressMutation) ResetCity() {
	m.city = nil
}

// SetRegion sets the "Region" field.
func (m *AddressMutation) SetRegion(s string) {
	m._Region = &s
}

// Region returns the value of the "Region" field in the mutation.
func (m *AddressMutation) Region() (r string, exists bool) {
	v := m._Region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "Region" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "Region" field.
func (m *AddressMutation) ResetRegion() {
	m._Region = nil
}

// SetAddress sets the "address" field.
func (m *AddressMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AddressMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AddressMutation) ResetAddress() {
	m.address = nil
}

// SetOtherInformation sets the "other_information" field.
func (m *AddressMutation) SetOtherInformation(s string) {
	m.other_information = &s
}

// OtherInformation returns the value of the "other_information" field in the mutation.
func (m *AddressMutation) OtherInformation() (r string, exists bool) {
	v := m.other_information
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherInformation returns the old "other_information" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldOtherInformation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherInformation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherInformation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherInformation: %w", err)
	}
	return oldValue.OtherInformation, nil
}

// ClearOtherInformation clears the value of the "other_information" field.
func (m *AddressMutation) ClearOtherInformation() {
	m.other_information = nil
	m.clearedFields[address.FieldOtherInformation] = struct{}{}
}

// OtherInformationCleared returns if the "other_information" field was cleared in this mutation.
func (m *AddressMutation) OtherInformationCleared() bool {
	_, ok := m.clearedFields[address.FieldOtherInformation]
	return ok
}

// ResetOtherInformation resets all changes to the "other_information" field.
func (m *AddressMutation) ResetOtherInformation() {
	m.other_information = nil
	delete(m.clearedFields, address.FieldOtherInformation)
}

// SetDefault sets the "default" field.
func (m *AddressMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *AddressMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *AddressMutation) ResetDefault() {
	m._default = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *AddressMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *AddressMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *AddressMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *AddressMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *AddressMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *AddressMutation) SetAgentID(id int) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *AddressMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *AddressMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *AddressMutation) AgentID() (id int, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) AgentIDs() (ids []int) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *AddressMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *AddressMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *AddressMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *AddressMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *AddressMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *AddressMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *AddressMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *AddressMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *AddressMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *AddressMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *AddressMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *AddressMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *AddressMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, address.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, address.FieldUpdatedAt)
	}
	if m.last_name != nil {
		fields = append(fields, address.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, address.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, address.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, address.FieldOtherPhone)
	}
	if m.digital_address != nil {
		fields = append(fields, address.FieldDigitalAddress)
	}
	if m.city != nil {
		fields = append(fields, address.FieldCity)
	}
	if m._Region != nil {
		fields = append(fields, address.FieldRegion)
	}
	if m.address != nil {
		fields = append(fields, address.FieldAddress)
	}
	if m.other_information != nil {
		fields = append(fields, address.FieldOtherInformation)
	}
	if m._default != nil {
		fields = append(fields, address.FieldDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldCreatedAt:
		return m.CreatedAt()
	case address.FieldUpdatedAt:
		return m.UpdatedAt()
	case address.FieldLastName:
		return m.LastName()
	case address.FieldOtherName:
		return m.OtherName()
	case address.FieldPhone:
		return m.Phone()
	case address.FieldOtherPhone:
		return m.OtherPhone()
	case address.FieldDigitalAddress:
		return m.DigitalAddress()
	case address.FieldCity:
		return m.City()
	case address.FieldRegion:
		return m.Region()
	case address.FieldAddress:
		return m.Address()
	case address.FieldOtherInformation:
		return m.OtherInformation()
	case address.FieldDefault:
		return m.Default()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case address.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case address.FieldLastName:
		return m.OldLastName(ctx)
	case address.FieldOtherName:
		return m.OldOtherName(ctx)
	case address.FieldPhone:
		return m.OldPhone(ctx)
	case address.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case address.FieldDigitalAddress:
		return m.OldDigitalAddress(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldRegion:
		return m.OldRegion(ctx)
	case address.FieldAddress:
		return m.OldAddress(ctx)
	case address.FieldOtherInformation:
		return m.OldOtherInformation(ctx)
	case address.FieldDefault:
		return m.OldDefault(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case address.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case address.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case address.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case address.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case address.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case address.FieldDigitalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigitalAddress(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case address.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case address.FieldOtherInformation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherInformation(v)
		return nil
	case address.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldOtherPhone) {
		fields = append(fields, address.FieldOtherPhone)
	}
	if m.FieldCleared(address.FieldDigitalAddress) {
		fields = append(fields, address.FieldDigitalAddress)
	}
	if m.FieldCleared(address.FieldOtherInformation) {
		fields = append(fields, address.FieldOtherInformation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	case address.FieldDigitalAddress:
		m.ClearDigitalAddress()
		return nil
	case address.FieldOtherInformation:
		m.ClearOtherInformation()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case address.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case address.FieldLastName:
		m.ResetLastName()
		return nil
	case address.FieldOtherName:
		m.ResetOtherName()
		return nil
	case address.FieldPhone:
		m.ResetPhone()
		return nil
	case address.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case address.FieldDigitalAddress:
		m.ResetDigitalAddress()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldRegion:
		m.ResetRegion()
		return nil
	case address.FieldAddress:
		m.ResetAddress()
		return nil
	case address.FieldOtherInformation:
		m.ResetOtherInformation()
		return nil
	case address.FieldDefault:
		m.ResetDefault()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.merchant != nil {
		edges = append(edges, address.EdgeMerchant)
	}
	if m.agent != nil {
		edges = append(edges, address.EdgeAgent)
	}
	if m.customer != nil {
		edges = append(edges, address.EdgeCustomer)
	}
	if m.orders != nil {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedorders != nil {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmerchant {
		edges = append(edges, address.EdgeMerchant)
	}
	if m.clearedagent {
		edges = append(edges, address.EdgeAgent)
	}
	if m.clearedcustomer {
		edges = append(edges, address.EdgeCustomer)
	}
	if m.clearedorders {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeMerchant:
		return m.clearedmerchant
	case address.EdgeAgent:
		return m.clearedagent
	case address.EdgeCustomer:
		return m.clearedcustomer
	case address.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	case address.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case address.EdgeAgent:
		m.ClearAgent()
		return nil
	case address.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case address.EdgeAgent:
		m.ResetAgent()
		return nil
	case address.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case address.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	username      *string
	password      *[]byte
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Admin, error)
	predicates    []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *AdminMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdminMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminMutation) ResetPassword() {
	m.password = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, admin.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, admin.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	case admin.FieldUsername:
		return m.Username()
	case admin.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admin.FieldUsername:
		return m.OldUsername(ctx)
	case admin.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case admin.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admin.FieldUsername:
		m.ResetUsername()
		return nil
	case admin.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	username          *string
	password          *[]byte
	ghana_card        *string
	last_name         *string
	other_name        *string
	phone             *string
	other_phone       *string
	address           *string
	digital_address   *string
	clearedFields     map[string]struct{}
	addresses         map[int]struct{}
	removedaddresses  map[int]struct{}
	clearedaddresses  bool
	orders            map[int]struct{}
	removedorders     map[int]struct{}
	clearedorders     bool
	baskets           map[int]struct{}
	removedbaskets    map[int]struct{}
	clearedbaskets    bool
	favourites        map[int]struct{}
	removedfavourites map[int]struct{}
	clearedfavourites bool
	done              bool
	oldValue          func(context.Context) (*Agent, error)
	predicates        []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id int) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *AgentMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AgentMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AgentMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AgentMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *AgentMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AgentMutation) ResetPassword() {
	m.password = nil
}

// SetGhanaCard sets the "ghana_card" field.
func (m *AgentMutation) SetGhanaCard(s string) {
	m.ghana_card = &s
}

// GhanaCard returns the value of the "ghana_card" field in the mutation.
func (m *AgentMutation) GhanaCard() (r string, exists bool) {
	v := m.ghana_card
	if v == nil {
		return
	}
	return *v, true
}

// OldGhanaCard returns the old "ghana_card" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldGhanaCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGhanaCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGhanaCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGhanaCard: %w", err)
	}
	return oldValue.GhanaCard, nil
}

// ResetGhanaCard resets all changes to the "ghana_card" field.
func (m *AgentMutation) ResetGhanaCard() {
	m.ghana_card = nil
}

// SetLastName sets the "last_name" field.
func (m *AgentMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AgentMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AgentMutation) ResetLastName() {
	m.last_name = nil
}

// SetOtherName sets the "other_name" field.
func (m *AgentMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *AgentMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *AgentMutation) ResetOtherName() {
	m.other_name = nil
}

// SetPhone sets the "phone" field.
func (m *AgentMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AgentMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *AgentMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *AgentMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *AgentMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldOtherPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *AgentMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[agent.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *AgentMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[agent.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *AgentMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, agent.FieldOtherPhone)
}

// SetAddress sets the "address" field.
func (m *AgentMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AgentMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AgentMutation) ResetAddress() {
	m.address = nil
}

// SetDigitalAddress sets the "digital_address" field.
func (m *AgentMutation) SetDigitalAddress(s string) {
	m.digital_address = &s
}

// DigitalAddress returns the value of the "digital_address" field in the mutation.
func (m *AgentMutation) DigitalAddress() (r string, exists bool) {
	v := m.digital_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDigitalAddress returns the old "digital_address" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDigitalAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigitalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigitalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigitalAddress: %w", err)
	}
	return oldValue.DigitalAddress, nil
}

// ResetDigitalAddress resets all changes to the "digital_address" field.
func (m *AgentMutation) ResetDigitalAddress() {
	m.digital_address = nil
}

// AddAddressIDs adds the "addresses" edge to the Address entity by ids.
func (m *AgentMutation) AddAddressIDs(ids ...int) {
	if m.addresses == nil {
		m.addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *AgentMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *AgentMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the Address entity by IDs.
func (m *AgentMutation) RemoveAddressIDs(ids ...int) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the Address entity.
func (m *AgentMutation) RemovedAddressesIDs() (ids []int) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *AgentMutation) AddressesIDs() (ids []int) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *AgentMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *AgentMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *AgentMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *AgentMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *AgentMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *AgentMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *AgentMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *AgentMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddBasketIDs adds the "baskets" edge to the Basket entity by ids.
func (m *AgentMutation) AddBasketIDs(ids ...int) {
	if m.baskets == nil {
		m.baskets = make(map[int]struct{})
	}
	for i := range ids {
		m.baskets[ids[i]] = struct{}{}
	}
}

// ClearBaskets clears the "baskets" edge to the Basket entity.
func (m *AgentMutation) ClearBaskets() {
	m.clearedbaskets = true
}

// BasketsCleared reports if the "baskets" edge to the Basket entity was cleared.
func (m *AgentMutation) BasketsCleared() bool {
	return m.clearedbaskets
}

// RemoveBasketIDs removes the "baskets" edge to the Basket entity by IDs.
func (m *AgentMutation) RemoveBasketIDs(ids ...int) {
	if m.removedbaskets == nil {
		m.removedbaskets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baskets, ids[i])
		m.removedbaskets[ids[i]] = struct{}{}
	}
}

// RemovedBaskets returns the removed IDs of the "baskets" edge to the Basket entity.
func (m *AgentMutation) RemovedBasketsIDs() (ids []int) {
	for id := range m.removedbaskets {
		ids = append(ids, id)
	}
	return
}

// BasketsIDs returns the "baskets" edge IDs in the mutation.
func (m *AgentMutation) BasketsIDs() (ids []int) {
	for id := range m.baskets {
		ids = append(ids, id)
	}
	return
}

// ResetBaskets resets all changes to the "baskets" edge.
func (m *AgentMutation) ResetBaskets() {
	m.baskets = nil
	m.clearedbaskets = false
	m.removedbaskets = nil
}

// AddFavouriteIDs adds the "favourites" edge to the Favourite entity by ids.
func (m *AgentMutation) AddFavouriteIDs(ids ...int) {
	if m.favourites == nil {
		m.favourites = make(map[int]struct{})
	}
	for i := range ids {
		m.favourites[ids[i]] = struct{}{}
	}
}

// ClearFavourites clears the "favourites" edge to the Favourite entity.
func (m *AgentMutation) ClearFavourites() {
	m.clearedfavourites = true
}

// FavouritesCleared reports if the "favourites" edge to the Favourite entity was cleared.
func (m *AgentMutation) FavouritesCleared() bool {
	return m.clearedfavourites
}

// RemoveFavouriteIDs removes the "favourites" edge to the Favourite entity by IDs.
func (m *AgentMutation) RemoveFavouriteIDs(ids ...int) {
	if m.removedfavourites == nil {
		m.removedfavourites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favourites, ids[i])
		m.removedfavourites[ids[i]] = struct{}{}
	}
}

// RemovedFavourites returns the removed IDs of the "favourites" edge to the Favourite entity.
func (m *AgentMutation) RemovedFavouritesIDs() (ids []int) {
	for id := range m.removedfavourites {
		ids = append(ids, id)
	}
	return
}

// FavouritesIDs returns the "favourites" edge IDs in the mutation.
func (m *AgentMutation) FavouritesIDs() (ids []int) {
	for id := range m.favourites {
		ids = append(ids, id)
	}
	return
}

// ResetFavourites resets all changes to the "favourites" edge.
func (m *AgentMutation) ResetFavourites() {
	m.favourites = nil
	m.clearedfavourites = false
	m.removedfavourites = nil
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, agent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agent.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, agent.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, agent.FieldPassword)
	}
	if m.ghana_card != nil {
		fields = append(fields, agent.FieldGhanaCard)
	}
	if m.last_name != nil {
		fields = append(fields, agent.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, agent.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, agent.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, agent.FieldOtherPhone)
	}
	if m.address != nil {
		fields = append(fields, agent.FieldAddress)
	}
	if m.digital_address != nil {
		fields = append(fields, agent.FieldDigitalAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldCreatedAt:
		return m.CreatedAt()
	case agent.FieldUpdatedAt:
		return m.UpdatedAt()
	case agent.FieldUsername:
		return m.Username()
	case agent.FieldPassword:
		return m.Password()
	case agent.FieldGhanaCard:
		return m.GhanaCard()
	case agent.FieldLastName:
		return m.LastName()
	case agent.FieldOtherName:
		return m.OtherName()
	case agent.FieldPhone:
		return m.Phone()
	case agent.FieldOtherPhone:
		return m.OtherPhone()
	case agent.FieldAddress:
		return m.Address()
	case agent.FieldDigitalAddress:
		return m.DigitalAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case agent.FieldUsername:
		return m.OldUsername(ctx)
	case agent.FieldPassword:
		return m.OldPassword(ctx)
	case agent.FieldGhanaCard:
		return m.OldGhanaCard(ctx)
	case agent.FieldLastName:
		return m.OldLastName(ctx)
	case agent.FieldOtherName:
		return m.OldOtherName(ctx)
	case agent.FieldPhone:
		return m.OldPhone(ctx)
	case agent.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case agent.FieldAddress:
		return m.OldAddress(ctx)
	case agent.FieldDigitalAddress:
		return m.OldDigitalAddress(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case agent.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case agent.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case agent.FieldGhanaCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGhanaCard(v)
		return nil
	case agent.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case agent.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case agent.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case agent.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case agent.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case agent.FieldDigitalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigitalAddress(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agent.FieldOtherPhone) {
		fields = append(fields, agent.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	switch name {
	case agent.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case agent.FieldUsername:
		m.ResetUsername()
		return nil
	case agent.FieldPassword:
		m.ResetPassword()
		return nil
	case agent.FieldGhanaCard:
		m.ResetGhanaCard()
		return nil
	case agent.FieldLastName:
		m.ResetLastName()
		return nil
	case agent.FieldOtherName:
		m.ResetOtherName()
		return nil
	case agent.FieldPhone:
		m.ResetPhone()
		return nil
	case agent.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case agent.FieldAddress:
		m.ResetAddress()
		return nil
	case agent.FieldDigitalAddress:
		m.ResetDigitalAddress()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.addresses != nil {
		edges = append(edges, agent.EdgeAddresses)
	}
	if m.orders != nil {
		edges = append(edges, agent.EdgeOrders)
	}
	if m.baskets != nil {
		edges = append(edges, agent.EdgeBaskets)
	}
	if m.favourites != nil {
		edges = append(edges, agent.EdgeFavourites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeBaskets:
		ids := make([]ent.Value, 0, len(m.baskets))
		for id := range m.baskets {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.favourites))
		for id := range m.favourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedaddresses != nil {
		edges = append(edges, agent.EdgeAddresses)
	}
	if m.removedorders != nil {
		edges = append(edges, agent.EdgeOrders)
	}
	if m.removedbaskets != nil {
		edges = append(edges, agent.EdgeBaskets)
	}
	if m.removedfavourites != nil {
		edges = append(edges, agent.EdgeFavourites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeBaskets:
		ids := make([]ent.Value, 0, len(m.removedbaskets))
		for id := range m.removedbaskets {
			ids = append(ids, id)
		}
		return ids
	case agent.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.removedfavourites))
		for id := range m.removedfavourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedaddresses {
		edges = append(edges, agent.EdgeAddresses)
	}
	if m.clearedorders {
		edges = append(edges, agent.EdgeOrders)
	}
	if m.clearedbaskets {
		edges = append(edges, agent.EdgeBaskets)
	}
	if m.clearedfavourites {
		edges = append(edges, agent.EdgeFavourites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeAddresses:
		return m.clearedaddresses
	case agent.EdgeOrders:
		return m.clearedorders
	case agent.EdgeBaskets:
		return m.clearedbaskets
	case agent.EdgeFavourites:
		return m.clearedfavourites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case agent.EdgeOrders:
		m.ResetOrders()
		return nil
	case agent.EdgeBaskets:
		m.ResetBaskets()
		return nil
	case agent.EdgeFavourites:
		m.ResetFavourites()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// BasketMutation represents an operation that mutates the Basket nodes in the graph.
type BasketMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	merchant        *int
	clearedmerchant bool
	agent           *int
	clearedagent    bool
	customer        *int
	clearedcustomer bool
	product         *int
	clearedproduct  bool
	done            bool
	oldValue        func(context.Context) (*Basket, error)
	predicates      []predicate.Basket
}

var _ ent.Mutation = (*BasketMutation)(nil)

// basketOption allows management of the mutation configuration using functional options.
type basketOption func(*BasketMutation)

// newBasketMutation creates new mutation for the Basket entity.
func newBasketMutation(c config, op Op, opts ...basketOption) *BasketMutation {
	m := &BasketMutation{
		config:        c,
		op:            op,
		typ:           TypeBasket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBasketID sets the ID field of the mutation.
func withBasketID(id int) basketOption {
	return func(m *BasketMutation) {
		var (
			err   error
			once  sync.Once
			value *Basket
		)
		m.oldValue = func(ctx context.Context) (*Basket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Basket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBasket sets the old Basket of the mutation.
func withBasket(node *Basket) basketOption {
	return func(m *BasketMutation) {
		m.oldValue = func(context.Context) (*Basket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BasketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BasketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BasketMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BasketMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Basket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BasketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BasketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Basket entity.
// If the Basket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BasketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BasketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BasketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Basket entity.
// If the Basket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BasketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BasketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *BasketMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *BasketMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *BasketMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *BasketMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *BasketMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *BasketMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *BasketMutation) SetAgentID(id int) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *BasketMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *BasketMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *BasketMutation) AgentID() (id int, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *BasketMutation) AgentIDs() (ids []int) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *BasketMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *BasketMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *BasketMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *BasketMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *BasketMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *BasketMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *BasketMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *BasketMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *BasketMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *BasketMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *BasketMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *BasketMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *BasketMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the BasketMutation builder.
func (m *BasketMutation) Where(ps ...predicate.Basket) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BasketMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Basket).
func (m *BasketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BasketMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, basket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, basket.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BasketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case basket.FieldCreatedAt:
		return m.CreatedAt()
	case basket.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BasketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case basket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case basket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Basket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BasketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case basket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case basket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Basket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BasketMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BasketMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BasketMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Basket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BasketMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BasketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BasketMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Basket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BasketMutation) ResetField(name string) error {
	switch name {
	case basket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case basket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Basket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BasketMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.merchant != nil {
		edges = append(edges, basket.EdgeMerchant)
	}
	if m.agent != nil {
		edges = append(edges, basket.EdgeAgent)
	}
	if m.customer != nil {
		edges = append(edges, basket.EdgeCustomer)
	}
	if m.product != nil {
		edges = append(edges, basket.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BasketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case basket.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case basket.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case basket.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case basket.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BasketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BasketMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BasketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmerchant {
		edges = append(edges, basket.EdgeMerchant)
	}
	if m.clearedagent {
		edges = append(edges, basket.EdgeAgent)
	}
	if m.clearedcustomer {
		edges = append(edges, basket.EdgeCustomer)
	}
	if m.clearedproduct {
		edges = append(edges, basket.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BasketMutation) EdgeCleared(name string) bool {
	switch name {
	case basket.EdgeMerchant:
		return m.clearedmerchant
	case basket.EdgeAgent:
		return m.clearedagent
	case basket.EdgeCustomer:
		return m.clearedcustomer
	case basket.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BasketMutation) ClearEdge(name string) error {
	switch name {
	case basket.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case basket.EdgeAgent:
		m.ClearAgent()
		return nil
	case basket.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case basket.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Basket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BasketMutation) ResetEdge(name string) error {
	switch name {
	case basket.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case basket.EdgeAgent:
		m.ResetAgent()
		return nil
	case basket.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case basket.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Basket edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	username          *string
	password          *[]byte
	first_name        *string
	last_name         *string
	phone             *string
	other_phone       *string
	clearedFields     map[string]struct{}
	addresses         map[int]struct{}
	removedaddresses  map[int]struct{}
	clearedaddresses  bool
	orders            map[int]struct{}
	removedorders     map[int]struct{}
	clearedorders     bool
	baskets           map[int]struct{}
	removedbaskets    map[int]struct{}
	clearedbaskets    bool
	favourites        map[int]struct{}
	removedfavourites map[int]struct{}
	clearedfavourites bool
	done              bool
	oldValue          func(context.Context) (*Customer, error)
	predicates        []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *CustomerMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *CustomerMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *CustomerMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *CustomerMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *CustomerMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *CustomerMutation) ResetPassword() {
	m.password = nil
}

// SetFirstName sets the "first_name" field.
func (m *CustomerMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *CustomerMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *CustomerMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *CustomerMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *CustomerMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *CustomerMutation) ResetLastName() {
	m.last_name = nil
}

// SetPhone sets the "phone" field.
func (m *CustomerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CustomerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CustomerMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *CustomerMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *CustomerMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldOtherPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *CustomerMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[customer.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *CustomerMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[customer.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *CustomerMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, customer.FieldOtherPhone)
}

// AddAddressIDs adds the "addresses" edge to the Address entity by ids.
func (m *CustomerMutation) AddAddressIDs(ids ...int) {
	if m.addresses == nil {
		m.addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *CustomerMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *CustomerMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the Address entity by IDs.
func (m *CustomerMutation) RemoveAddressIDs(ids ...int) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the Address entity.
func (m *CustomerMutation) RemovedAddressesIDs() (ids []int) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *CustomerMutation) AddressesIDs() (ids []int) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *CustomerMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *CustomerMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *CustomerMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *CustomerMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *CustomerMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *CustomerMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *CustomerMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *CustomerMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddBasketIDs adds the "baskets" edge to the Basket entity by ids.
func (m *CustomerMutation) AddBasketIDs(ids ...int) {
	if m.baskets == nil {
		m.baskets = make(map[int]struct{})
	}
	for i := range ids {
		m.baskets[ids[i]] = struct{}{}
	}
}

// ClearBaskets clears the "baskets" edge to the Basket entity.
func (m *CustomerMutation) ClearBaskets() {
	m.clearedbaskets = true
}

// BasketsCleared reports if the "baskets" edge to the Basket entity was cleared.
func (m *CustomerMutation) BasketsCleared() bool {
	return m.clearedbaskets
}

// RemoveBasketIDs removes the "baskets" edge to the Basket entity by IDs.
func (m *CustomerMutation) RemoveBasketIDs(ids ...int) {
	if m.removedbaskets == nil {
		m.removedbaskets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baskets, ids[i])
		m.removedbaskets[ids[i]] = struct{}{}
	}
}

// RemovedBaskets returns the removed IDs of the "baskets" edge to the Basket entity.
func (m *CustomerMutation) RemovedBasketsIDs() (ids []int) {
	for id := range m.removedbaskets {
		ids = append(ids, id)
	}
	return
}

// BasketsIDs returns the "baskets" edge IDs in the mutation.
func (m *CustomerMutation) BasketsIDs() (ids []int) {
	for id := range m.baskets {
		ids = append(ids, id)
	}
	return
}

// ResetBaskets resets all changes to the "baskets" edge.
func (m *CustomerMutation) ResetBaskets() {
	m.baskets = nil
	m.clearedbaskets = false
	m.removedbaskets = nil
}

// AddFavouriteIDs adds the "favourites" edge to the Favourite entity by ids.
func (m *CustomerMutation) AddFavouriteIDs(ids ...int) {
	if m.favourites == nil {
		m.favourites = make(map[int]struct{})
	}
	for i := range ids {
		m.favourites[ids[i]] = struct{}{}
	}
}

// ClearFavourites clears the "favourites" edge to the Favourite entity.
func (m *CustomerMutation) ClearFavourites() {
	m.clearedfavourites = true
}

// FavouritesCleared reports if the "favourites" edge to the Favourite entity was cleared.
func (m *CustomerMutation) FavouritesCleared() bool {
	return m.clearedfavourites
}

// RemoveFavouriteIDs removes the "favourites" edge to the Favourite entity by IDs.
func (m *CustomerMutation) RemoveFavouriteIDs(ids ...int) {
	if m.removedfavourites == nil {
		m.removedfavourites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favourites, ids[i])
		m.removedfavourites[ids[i]] = struct{}{}
	}
}

// RemovedFavourites returns the removed IDs of the "favourites" edge to the Favourite entity.
func (m *CustomerMutation) RemovedFavouritesIDs() (ids []int) {
	for id := range m.removedfavourites {
		ids = append(ids, id)
	}
	return
}

// FavouritesIDs returns the "favourites" edge IDs in the mutation.
func (m *CustomerMutation) FavouritesIDs() (ids []int) {
	for id := range m.favourites {
		ids = append(ids, id)
	}
	return
}

// ResetFavourites resets all changes to the "favourites" edge.
func (m *CustomerMutation) ResetFavourites() {
	m.favourites = nil
	m.clearedfavourites = false
	m.removedfavourites = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, customer.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, customer.FieldPassword)
	}
	if m.first_name != nil {
		fields = append(fields, customer.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, customer.FieldLastName)
	}
	if m.phone != nil {
		fields = append(fields, customer.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, customer.FieldOtherPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldUsername:
		return m.Username()
	case customer.FieldPassword:
		return m.Password()
	case customer.FieldFirstName:
		return m.FirstName()
	case customer.FieldLastName:
		return m.LastName()
	case customer.FieldPhone:
		return m.Phone()
	case customer.FieldOtherPhone:
		return m.OtherPhone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldUsername:
		return m.OldUsername(ctx)
	case customer.FieldPassword:
		return m.OldPassword(ctx)
	case customer.FieldFirstName:
		return m.OldFirstName(ctx)
	case customer.FieldLastName:
		return m.OldLastName(ctx)
	case customer.FieldPhone:
		return m.OldPhone(ctx)
	case customer.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case customer.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case customer.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case customer.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case customer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case customer.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldOtherPhone) {
		fields = append(fields, customer.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldUsername:
		m.ResetUsername()
		return nil
	case customer.FieldPassword:
		m.ResetPassword()
		return nil
	case customer.FieldFirstName:
		m.ResetFirstName()
		return nil
	case customer.FieldLastName:
		m.ResetLastName()
		return nil
	case customer.FieldPhone:
		m.ResetPhone()
		return nil
	case customer.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.addresses != nil {
		edges = append(edges, customer.EdgeAddresses)
	}
	if m.orders != nil {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.baskets != nil {
		edges = append(edges, customer.EdgeBaskets)
	}
	if m.favourites != nil {
		edges = append(edges, customer.EdgeFavourites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeBaskets:
		ids := make([]ent.Value, 0, len(m.baskets))
		for id := range m.baskets {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.favourites))
		for id := range m.favourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedaddresses != nil {
		edges = append(edges, customer.EdgeAddresses)
	}
	if m.removedorders != nil {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.removedbaskets != nil {
		edges = append(edges, customer.EdgeBaskets)
	}
	if m.removedfavourites != nil {
		edges = append(edges, customer.EdgeFavourites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeBaskets:
		ids := make([]ent.Value, 0, len(m.removedbaskets))
		for id := range m.removedbaskets {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.removedfavourites))
		for id := range m.removedfavourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedaddresses {
		edges = append(edges, customer.EdgeAddresses)
	}
	if m.clearedorders {
		edges = append(edges, customer.EdgeOrders)
	}
	if m.clearedbaskets {
		edges = append(edges, customer.EdgeBaskets)
	}
	if m.clearedfavourites {
		edges = append(edges, customer.EdgeFavourites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeAddresses:
		return m.clearedaddresses
	case customer.EdgeOrders:
		return m.clearedorders
	case customer.EdgeBaskets:
		return m.clearedbaskets
	case customer.EdgeFavourites:
		return m.clearedfavourites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case customer.EdgeOrders:
		m.ResetOrders()
		return nil
	case customer.EdgeBaskets:
		m.ResetBaskets()
		return nil
	case customer.EdgeFavourites:
		m.ResetFavourites()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// FavouriteMutation represents an operation that mutates the Favourite nodes in the graph.
type FavouriteMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	merchant        *int
	clearedmerchant bool
	agent           *int
	clearedagent    bool
	customer        *int
	clearedcustomer bool
	product         *int
	clearedproduct  bool
	done            bool
	oldValue        func(context.Context) (*Favourite, error)
	predicates      []predicate.Favourite
}

var _ ent.Mutation = (*FavouriteMutation)(nil)

// favouriteOption allows management of the mutation configuration using functional options.
type favouriteOption func(*FavouriteMutation)

// newFavouriteMutation creates new mutation for the Favourite entity.
func newFavouriteMutation(c config, op Op, opts ...favouriteOption) *FavouriteMutation {
	m := &FavouriteMutation{
		config:        c,
		op:            op,
		typ:           TypeFavourite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFavouriteID sets the ID field of the mutation.
func withFavouriteID(id int) favouriteOption {
	return func(m *FavouriteMutation) {
		var (
			err   error
			once  sync.Once
			value *Favourite
		)
		m.oldValue = func(ctx context.Context) (*Favourite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Favourite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFavourite sets the old Favourite of the mutation.
func withFavourite(node *Favourite) favouriteOption {
	return func(m *FavouriteMutation) {
		m.oldValue = func(context.Context) (*Favourite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FavouriteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FavouriteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FavouriteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FavouriteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Favourite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FavouriteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FavouriteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Favourite entity.
// If the Favourite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavouriteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FavouriteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FavouriteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FavouriteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Favourite entity.
// If the Favourite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavouriteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FavouriteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *FavouriteMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *FavouriteMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *FavouriteMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *FavouriteMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *FavouriteMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *FavouriteMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *FavouriteMutation) SetAgentID(id int) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *FavouriteMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *FavouriteMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *FavouriteMutation) AgentID() (id int, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *FavouriteMutation) AgentIDs() (ids []int) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *FavouriteMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *FavouriteMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *FavouriteMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *FavouriteMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *FavouriteMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *FavouriteMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *FavouriteMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *FavouriteMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *FavouriteMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *FavouriteMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *FavouriteMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *FavouriteMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *FavouriteMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the FavouriteMutation builder.
func (m *FavouriteMutation) Where(ps ...predicate.Favourite) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FavouriteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Favourite).
func (m *FavouriteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FavouriteMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, favourite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, favourite.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FavouriteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case favourite.FieldCreatedAt:
		return m.CreatedAt()
	case favourite.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FavouriteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case favourite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case favourite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Favourite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavouriteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case favourite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case favourite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Favourite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FavouriteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FavouriteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavouriteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Favourite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FavouriteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FavouriteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FavouriteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Favourite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FavouriteMutation) ResetField(name string) error {
	switch name {
	case favourite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case favourite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Favourite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FavouriteMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.merchant != nil {
		edges = append(edges, favourite.EdgeMerchant)
	}
	if m.agent != nil {
		edges = append(edges, favourite.EdgeAgent)
	}
	if m.customer != nil {
		edges = append(edges, favourite.EdgeCustomer)
	}
	if m.product != nil {
		edges = append(edges, favourite.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FavouriteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case favourite.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case favourite.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case favourite.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case favourite.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FavouriteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FavouriteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FavouriteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmerchant {
		edges = append(edges, favourite.EdgeMerchant)
	}
	if m.clearedagent {
		edges = append(edges, favourite.EdgeAgent)
	}
	if m.clearedcustomer {
		edges = append(edges, favourite.EdgeCustomer)
	}
	if m.clearedproduct {
		edges = append(edges, favourite.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FavouriteMutation) EdgeCleared(name string) bool {
	switch name {
	case favourite.EdgeMerchant:
		return m.clearedmerchant
	case favourite.EdgeAgent:
		return m.clearedagent
	case favourite.EdgeCustomer:
		return m.clearedcustomer
	case favourite.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FavouriteMutation) ClearEdge(name string) error {
	switch name {
	case favourite.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case favourite.EdgeAgent:
		m.ClearAgent()
		return nil
	case favourite.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case favourite.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Favourite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FavouriteMutation) ResetEdge(name string) error {
	switch name {
	case favourite.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case favourite.EdgeAgent:
		m.ResetAgent()
		return nil
	case favourite.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case favourite.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Favourite edge %s", name)
}

// MerchantMutation represents an operation that mutates the Merchant nodes in the graph.
type MerchantMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	username          *string
	password          *[]byte
	_type             *string
	clearedFields     map[string]struct{}
	supplier          *int
	clearedsupplier   bool
	retailer          *int
	clearedretailer   bool
	store             *int
	clearedstore      bool
	products          map[int]struct{}
	removedproducts   map[int]struct{}
	clearedproducts   bool
	addresses         map[int]struct{}
	removedaddresses  map[int]struct{}
	clearedaddresses  bool
	orders            map[int]struct{}
	removedorders     map[int]struct{}
	clearedorders     bool
	baskets           map[int]struct{}
	removedbaskets    map[int]struct{}
	clearedbaskets    bool
	favourites        map[int]struct{}
	removedfavourites map[int]struct{}
	clearedfavourites bool
	done              bool
	oldValue          func(context.Context) (*Merchant, error)
	predicates        []predicate.Merchant
}

var _ ent.Mutation = (*MerchantMutation)(nil)

// merchantOption allows management of the mutation configuration using functional options.
type merchantOption func(*MerchantMutation)

// newMerchantMutation creates new mutation for the Merchant entity.
func newMerchantMutation(c config, op Op, opts ...merchantOption) *MerchantMutation {
	m := &MerchantMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantID sets the ID field of the mutation.
func withMerchantID(id int) merchantOption {
	return func(m *MerchantMutation) {
		var (
			err   error
			once  sync.Once
			value *Merchant
		)
		m.oldValue = func(ctx context.Context) (*Merchant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Merchant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchant sets the old Merchant of the mutation.
func withMerchant(node *Merchant) merchantOption {
	return func(m *MerchantMutation) {
		m.oldValue = func(context.Context) (*Merchant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MerchantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MerchantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Merchant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MerchantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MerchantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MerchantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MerchantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MerchantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MerchantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *MerchantMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *MerchantMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *MerchantMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *MerchantMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *MerchantMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *MerchantMutation) ResetPassword() {
	m.password = nil
}

// SetType sets the "type" field.
func (m *MerchantMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MerchantMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Merchant entity.
// If the Merchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MerchantMutation) ResetType() {
	m._type = nil
}

// SetSupplierID sets the "supplier" edge to the SupplierMerchant entity by id.
func (m *MerchantMutation) SetSupplierID(id int) {
	m.supplier = &id
}

// ClearSupplier clears the "supplier" edge to the SupplierMerchant entity.
func (m *MerchantMutation) ClearSupplier() {
	m.clearedsupplier = true
}

// SupplierCleared reports if the "supplier" edge to the SupplierMerchant entity was cleared.
func (m *MerchantMutation) SupplierCleared() bool {
	return m.clearedsupplier
}

// SupplierID returns the "supplier" edge ID in the mutation.
func (m *MerchantMutation) SupplierID() (id int, exists bool) {
	if m.supplier != nil {
		return *m.supplier, true
	}
	return
}

// SupplierIDs returns the "supplier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupplierID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) SupplierIDs() (ids []int) {
	if id := m.supplier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupplier resets all changes to the "supplier" edge.
func (m *MerchantMutation) ResetSupplier() {
	m.supplier = nil
	m.clearedsupplier = false
}

// SetRetailerID sets the "retailer" edge to the RetailMerchant entity by id.
func (m *MerchantMutation) SetRetailerID(id int) {
	m.retailer = &id
}

// ClearRetailer clears the "retailer" edge to the RetailMerchant entity.
func (m *MerchantMutation) ClearRetailer() {
	m.clearedretailer = true
}

// RetailerCleared reports if the "retailer" edge to the RetailMerchant entity was cleared.
func (m *MerchantMutation) RetailerCleared() bool {
	return m.clearedretailer
}

// RetailerID returns the "retailer" edge ID in the mutation.
func (m *MerchantMutation) RetailerID() (id int, exists bool) {
	if m.retailer != nil {
		return *m.retailer, true
	}
	return
}

// RetailerIDs returns the "retailer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RetailerID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) RetailerIDs() (ids []int) {
	if id := m.retailer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRetailer resets all changes to the "retailer" edge.
func (m *MerchantMutation) ResetRetailer() {
	m.retailer = nil
	m.clearedretailer = false
}

// SetStoreID sets the "store" edge to the MerchantStore entity by id.
func (m *MerchantMutation) SetStoreID(id int) {
	m.store = &id
}

// ClearStore clears the "store" edge to the MerchantStore entity.
func (m *MerchantMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the MerchantStore entity was cleared.
func (m *MerchantMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreID returns the "store" edge ID in the mutation.
func (m *MerchantMutation) StoreID() (id int, exists bool) {
	if m.store != nil {
		return *m.store, true
	}
	return
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *MerchantMutation) StoreIDs() (ids []int) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *MerchantMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *MerchantMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *MerchantMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *MerchantMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *MerchantMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *MerchantMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *MerchantMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *MerchantMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddAddressIDs adds the "addresses" edge to the Address entity by ids.
func (m *MerchantMutation) AddAddressIDs(ids ...int) {
	if m.addresses == nil {
		m.addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *MerchantMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *MerchantMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the Address entity by IDs.
func (m *MerchantMutation) RemoveAddressIDs(ids ...int) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the Address entity.
func (m *MerchantMutation) RemovedAddressesIDs() (ids []int) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *MerchantMutation) AddressesIDs() (ids []int) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *MerchantMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *MerchantMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *MerchantMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *MerchantMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *MerchantMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *MerchantMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *MerchantMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *MerchantMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddBasketIDs adds the "baskets" edge to the Basket entity by ids.
func (m *MerchantMutation) AddBasketIDs(ids ...int) {
	if m.baskets == nil {
		m.baskets = make(map[int]struct{})
	}
	for i := range ids {
		m.baskets[ids[i]] = struct{}{}
	}
}

// ClearBaskets clears the "baskets" edge to the Basket entity.
func (m *MerchantMutation) ClearBaskets() {
	m.clearedbaskets = true
}

// BasketsCleared reports if the "baskets" edge to the Basket entity was cleared.
func (m *MerchantMutation) BasketsCleared() bool {
	return m.clearedbaskets
}

// RemoveBasketIDs removes the "baskets" edge to the Basket entity by IDs.
func (m *MerchantMutation) RemoveBasketIDs(ids ...int) {
	if m.removedbaskets == nil {
		m.removedbaskets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baskets, ids[i])
		m.removedbaskets[ids[i]] = struct{}{}
	}
}

// RemovedBaskets returns the removed IDs of the "baskets" edge to the Basket entity.
func (m *MerchantMutation) RemovedBasketsIDs() (ids []int) {
	for id := range m.removedbaskets {
		ids = append(ids, id)
	}
	return
}

// BasketsIDs returns the "baskets" edge IDs in the mutation.
func (m *MerchantMutation) BasketsIDs() (ids []int) {
	for id := range m.baskets {
		ids = append(ids, id)
	}
	return
}

// ResetBaskets resets all changes to the "baskets" edge.
func (m *MerchantMutation) ResetBaskets() {
	m.baskets = nil
	m.clearedbaskets = false
	m.removedbaskets = nil
}

// AddFavouriteIDs adds the "favourites" edge to the Favourite entity by ids.
func (m *MerchantMutation) AddFavouriteIDs(ids ...int) {
	if m.favourites == nil {
		m.favourites = make(map[int]struct{})
	}
	for i := range ids {
		m.favourites[ids[i]] = struct{}{}
	}
}

// ClearFavourites clears the "favourites" edge to the Favourite entity.
func (m *MerchantMutation) ClearFavourites() {
	m.clearedfavourites = true
}

// FavouritesCleared reports if the "favourites" edge to the Favourite entity was cleared.
func (m *MerchantMutation) FavouritesCleared() bool {
	return m.clearedfavourites
}

// RemoveFavouriteIDs removes the "favourites" edge to the Favourite entity by IDs.
func (m *MerchantMutation) RemoveFavouriteIDs(ids ...int) {
	if m.removedfavourites == nil {
		m.removedfavourites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favourites, ids[i])
		m.removedfavourites[ids[i]] = struct{}{}
	}
}

// RemovedFavourites returns the removed IDs of the "favourites" edge to the Favourite entity.
func (m *MerchantMutation) RemovedFavouritesIDs() (ids []int) {
	for id := range m.removedfavourites {
		ids = append(ids, id)
	}
	return
}

// FavouritesIDs returns the "favourites" edge IDs in the mutation.
func (m *MerchantMutation) FavouritesIDs() (ids []int) {
	for id := range m.favourites {
		ids = append(ids, id)
	}
	return
}

// ResetFavourites resets all changes to the "favourites" edge.
func (m *MerchantMutation) ResetFavourites() {
	m.favourites = nil
	m.clearedfavourites = false
	m.removedfavourites = nil
}

// Where appends a list predicates to the MerchantMutation builder.
func (m *MerchantMutation) Where(ps ...predicate.Merchant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MerchantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Merchant).
func (m *MerchantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, merchant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, merchant.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, merchant.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, merchant.FieldPassword)
	}
	if m._type != nil {
		fields = append(fields, merchant.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchant.FieldCreatedAt:
		return m.CreatedAt()
	case merchant.FieldUpdatedAt:
		return m.UpdatedAt()
	case merchant.FieldUsername:
		return m.Username()
	case merchant.FieldPassword:
		return m.Password()
	case merchant.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case merchant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case merchant.FieldUsername:
		return m.OldUsername(ctx)
	case merchant.FieldPassword:
		return m.OldPassword(ctx)
	case merchant.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Merchant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case merchant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case merchant.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case merchant.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case merchant.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Merchant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Merchant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Merchant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantMutation) ResetField(name string) error {
	switch name {
	case merchant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case merchant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case merchant.FieldUsername:
		m.ResetUsername()
		return nil
	case merchant.FieldPassword:
		m.ResetPassword()
		return nil
	case merchant.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Merchant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.supplier != nil {
		edges = append(edges, merchant.EdgeSupplier)
	}
	if m.retailer != nil {
		edges = append(edges, merchant.EdgeRetailer)
	}
	if m.store != nil {
		edges = append(edges, merchant.EdgeStore)
	}
	if m.products != nil {
		edges = append(edges, merchant.EdgeProducts)
	}
	if m.addresses != nil {
		edges = append(edges, merchant.EdgeAddresses)
	}
	if m.orders != nil {
		edges = append(edges, merchant.EdgeOrders)
	}
	if m.baskets != nil {
		edges = append(edges, merchant.EdgeBaskets)
	}
	if m.favourites != nil {
		edges = append(edges, merchant.EdgeFavourites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case merchant.EdgeSupplier:
		if id := m.supplier; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeRetailer:
		if id := m.retailer; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case merchant.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeBaskets:
		ids := make([]ent.Value, 0, len(m.baskets))
		for id := range m.baskets {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.favourites))
		for id := range m.favourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedproducts != nil {
		edges = append(edges, merchant.EdgeProducts)
	}
	if m.removedaddresses != nil {
		edges = append(edges, merchant.EdgeAddresses)
	}
	if m.removedorders != nil {
		edges = append(edges, merchant.EdgeOrders)
	}
	if m.removedbaskets != nil {
		edges = append(edges, merchant.EdgeBaskets)
	}
	if m.removedfavourites != nil {
		edges = append(edges, merchant.EdgeFavourites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case merchant.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeBaskets:
		ids := make([]ent.Value, 0, len(m.removedbaskets))
		for id := range m.removedbaskets {
			ids = append(ids, id)
		}
		return ids
	case merchant.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.removedfavourites))
		for id := range m.removedfavourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedsupplier {
		edges = append(edges, merchant.EdgeSupplier)
	}
	if m.clearedretailer {
		edges = append(edges, merchant.EdgeRetailer)
	}
	if m.clearedstore {
		edges = append(edges, merchant.EdgeStore)
	}
	if m.clearedproducts {
		edges = append(edges, merchant.EdgeProducts)
	}
	if m.clearedaddresses {
		edges = append(edges, merchant.EdgeAddresses)
	}
	if m.clearedorders {
		edges = append(edges, merchant.EdgeOrders)
	}
	if m.clearedbaskets {
		edges = append(edges, merchant.EdgeBaskets)
	}
	if m.clearedfavourites {
		edges = append(edges, merchant.EdgeFavourites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantMutation) EdgeCleared(name string) bool {
	switch name {
	case merchant.EdgeSupplier:
		return m.clearedsupplier
	case merchant.EdgeRetailer:
		return m.clearedretailer
	case merchant.EdgeStore:
		return m.clearedstore
	case merchant.EdgeProducts:
		return m.clearedproducts
	case merchant.EdgeAddresses:
		return m.clearedaddresses
	case merchant.EdgeOrders:
		return m.clearedorders
	case merchant.EdgeBaskets:
		return m.clearedbaskets
	case merchant.EdgeFavourites:
		return m.clearedfavourites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantMutation) ClearEdge(name string) error {
	switch name {
	case merchant.EdgeSupplier:
		m.ClearSupplier()
		return nil
	case merchant.EdgeRetailer:
		m.ClearRetailer()
		return nil
	case merchant.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Merchant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantMutation) ResetEdge(name string) error {
	switch name {
	case merchant.EdgeSupplier:
		m.ResetSupplier()
		return nil
	case merchant.EdgeRetailer:
		m.ResetRetailer()
		return nil
	case merchant.EdgeStore:
		m.ResetStore()
		return nil
	case merchant.EdgeProducts:
		m.ResetProducts()
		return nil
	case merchant.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case merchant.EdgeOrders:
		m.ResetOrders()
		return nil
	case merchant.EdgeBaskets:
		m.ResetBaskets()
		return nil
	case merchant.EdgeFavourites:
		m.ResetFavourites()
		return nil
	}
	return fmt.Errorf("unknown Merchant edge %s", name)
}

// MerchantStoreMutation represents an operation that mutates the MerchantStore nodes in the graph.
type MerchantStoreMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	about           *string
	desc_title      *string
	description     *string
	logo            *string
	images          *[]string
	default_account *merchantstore.DefaultAccount
	bank_account    **models.MerchantBankAccount
	momo_account    **models.MerchantMomoAccount
	clearedFields   map[string]struct{}
	merchant        *int
	clearedmerchant bool
	done            bool
	oldValue        func(context.Context) (*MerchantStore, error)
	predicates      []predicate.MerchantStore
}

var _ ent.Mutation = (*MerchantStoreMutation)(nil)

// merchantstoreOption allows management of the mutation configuration using functional options.
type merchantstoreOption func(*MerchantStoreMutation)

// newMerchantStoreMutation creates new mutation for the MerchantStore entity.
func newMerchantStoreMutation(c config, op Op, opts ...merchantstoreOption) *MerchantStoreMutation {
	m := &MerchantStoreMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchantStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantStoreID sets the ID field of the mutation.
func withMerchantStoreID(id int) merchantstoreOption {
	return func(m *MerchantStoreMutation) {
		var (
			err   error
			once  sync.Once
			value *MerchantStore
		)
		m.oldValue = func(ctx context.Context) (*MerchantStore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MerchantStore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchantStore sets the old MerchantStore of the mutation.
func withMerchantStore(node *MerchantStore) merchantstoreOption {
	return func(m *MerchantStoreMutation) {
		m.oldValue = func(context.Context) (*MerchantStore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantStoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantStoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MerchantStoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MerchantStoreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MerchantStore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MerchantStoreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MerchantStoreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MerchantStoreMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MerchantStoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MerchantStoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MerchantStoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *MerchantStoreMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MerchantStoreMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MerchantStoreMutation) ResetName() {
	m.name = nil
}

// SetAbout sets the "about" field.
func (m *MerchantStoreMutation) SetAbout(s string) {
	m.about = &s
}

// About returns the value of the "about" field in the mutation.
func (m *MerchantStoreMutation) About() (r string, exists bool) {
	v := m.about
	if v == nil {
		return
	}
	return *v, true
}

// OldAbout returns the old "about" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldAbout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbout: %w", err)
	}
	return oldValue.About, nil
}

// ResetAbout resets all changes to the "about" field.
func (m *MerchantStoreMutation) ResetAbout() {
	m.about = nil
}

// SetDescTitle sets the "desc_title" field.
func (m *MerchantStoreMutation) SetDescTitle(s string) {
	m.desc_title = &s
}

// DescTitle returns the value of the "desc_title" field in the mutation.
func (m *MerchantStoreMutation) DescTitle() (r string, exists bool) {
	v := m.desc_title
	if v == nil {
		return
	}
	return *v, true
}

// OldDescTitle returns the old "desc_title" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldDescTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescTitle: %w", err)
	}
	return oldValue.DescTitle, nil
}

// ResetDescTitle resets all changes to the "desc_title" field.
func (m *MerchantStoreMutation) ResetDescTitle() {
	m.desc_title = nil
}

// SetDescription sets the "description" field.
func (m *MerchantStoreMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MerchantStoreMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *MerchantStoreMutation) ResetDescription() {
	m.description = nil
}

// SetLogo sets the "logo" field.
func (m *MerchantStoreMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *MerchantStoreMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *MerchantStoreMutation) ResetLogo() {
	m.logo = nil
}

// SetImages sets the "images" field.
func (m *MerchantStoreMutation) SetImages(s []string) {
	m.images = &s
}

// Images returns the value of the "images" field in the mutation.
func (m *MerchantStoreMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// ClearImages clears the value of the "images" field.
func (m *MerchantStoreMutation) ClearImages() {
	m.images = nil
	m.clearedFields[merchantstore.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *MerchantStoreMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *MerchantStoreMutation) ResetImages() {
	m.images = nil
	delete(m.clearedFields, merchantstore.FieldImages)
}

// SetDefaultAccount sets the "default_account" field.
func (m *MerchantStoreMutation) SetDefaultAccount(ma merchantstore.DefaultAccount) {
	m.default_account = &ma
}

// DefaultAccount returns the value of the "default_account" field in the mutation.
func (m *MerchantStoreMutation) DefaultAccount() (r merchantstore.DefaultAccount, exists bool) {
	v := m.default_account
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultAccount returns the old "default_account" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldDefaultAccount(ctx context.Context) (v merchantstore.DefaultAccount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultAccount: %w", err)
	}
	return oldValue.DefaultAccount, nil
}

// ClearDefaultAccount clears the value of the "default_account" field.
func (m *MerchantStoreMutation) ClearDefaultAccount() {
	m.default_account = nil
	m.clearedFields[merchantstore.FieldDefaultAccount] = struct{}{}
}

// DefaultAccountCleared returns if the "default_account" field was cleared in this mutation.
func (m *MerchantStoreMutation) DefaultAccountCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldDefaultAccount]
	return ok
}

// ResetDefaultAccount resets all changes to the "default_account" field.
func (m *MerchantStoreMutation) ResetDefaultAccount() {
	m.default_account = nil
	delete(m.clearedFields, merchantstore.FieldDefaultAccount)
}

// SetBankAccount sets the "bank_account" field.
func (m *MerchantStoreMutation) SetBankAccount(mba *models.MerchantBankAccount) {
	m.bank_account = &mba
}

// BankAccount returns the value of the "bank_account" field in the mutation.
func (m *MerchantStoreMutation) BankAccount() (r *models.MerchantBankAccount, exists bool) {
	v := m.bank_account
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccount returns the old "bank_account" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldBankAccount(ctx context.Context) (v *models.MerchantBankAccount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccount: %w", err)
	}
	return oldValue.BankAccount, nil
}

// ClearBankAccount clears the value of the "bank_account" field.
func (m *MerchantStoreMutation) ClearBankAccount() {
	m.bank_account = nil
	m.clearedFields[merchantstore.FieldBankAccount] = struct{}{}
}

// BankAccountCleared returns if the "bank_account" field was cleared in this mutation.
func (m *MerchantStoreMutation) BankAccountCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldBankAccount]
	return ok
}

// ResetBankAccount resets all changes to the "bank_account" field.
func (m *MerchantStoreMutation) ResetBankAccount() {
	m.bank_account = nil
	delete(m.clearedFields, merchantstore.FieldBankAccount)
}

// SetMomoAccount sets the "momo_account" field.
func (m *MerchantStoreMutation) SetMomoAccount(mma *models.MerchantMomoAccount) {
	m.momo_account = &mma
}

// MomoAccount returns the value of the "momo_account" field in the mutation.
func (m *MerchantStoreMutation) MomoAccount() (r *models.MerchantMomoAccount, exists bool) {
	v := m.momo_account
	if v == nil {
		return
	}
	return *v, true
}

// OldMomoAccount returns the old "momo_account" field's value of the MerchantStore entity.
// If the MerchantStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantStoreMutation) OldMomoAccount(ctx context.Context) (v *models.MerchantMomoAccount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMomoAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMomoAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMomoAccount: %w", err)
	}
	return oldValue.MomoAccount, nil
}

// ClearMomoAccount clears the value of the "momo_account" field.
func (m *MerchantStoreMutation) ClearMomoAccount() {
	m.momo_account = nil
	m.clearedFields[merchantstore.FieldMomoAccount] = struct{}{}
}

// MomoAccountCleared returns if the "momo_account" field was cleared in this mutation.
func (m *MerchantStoreMutation) MomoAccountCleared() bool {
	_, ok := m.clearedFields[merchantstore.FieldMomoAccount]
	return ok
}

// ResetMomoAccount resets all changes to the "momo_account" field.
func (m *MerchantStoreMutation) ResetMomoAccount() {
	m.momo_account = nil
	delete(m.clearedFields, merchantstore.FieldMomoAccount)
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *MerchantStoreMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *MerchantStoreMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *MerchantStoreMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *MerchantStoreMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *MerchantStoreMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *MerchantStoreMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// Where appends a list predicates to the MerchantStoreMutation builder.
func (m *MerchantStoreMutation) Where(ps ...predicate.MerchantStore) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MerchantStoreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MerchantStore).
func (m *MerchantStoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantStoreMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, merchantstore.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, merchantstore.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, merchantstore.FieldName)
	}
	if m.about != nil {
		fields = append(fields, merchantstore.FieldAbout)
	}
	if m.desc_title != nil {
		fields = append(fields, merchantstore.FieldDescTitle)
	}
	if m.description != nil {
		fields = append(fields, merchantstore.FieldDescription)
	}
	if m.logo != nil {
		fields = append(fields, merchantstore.FieldLogo)
	}
	if m.images != nil {
		fields = append(fields, merchantstore.FieldImages)
	}
	if m.default_account != nil {
		fields = append(fields, merchantstore.FieldDefaultAccount)
	}
	if m.bank_account != nil {
		fields = append(fields, merchantstore.FieldBankAccount)
	}
	if m.momo_account != nil {
		fields = append(fields, merchantstore.FieldMomoAccount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantStoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchantstore.FieldCreatedAt:
		return m.CreatedAt()
	case merchantstore.FieldUpdatedAt:
		return m.UpdatedAt()
	case merchantstore.FieldName:
		return m.Name()
	case merchantstore.FieldAbout:
		return m.About()
	case merchantstore.FieldDescTitle:
		return m.DescTitle()
	case merchantstore.FieldDescription:
		return m.Description()
	case merchantstore.FieldLogo:
		return m.Logo()
	case merchantstore.FieldImages:
		return m.Images()
	case merchantstore.FieldDefaultAccount:
		return m.DefaultAccount()
	case merchantstore.FieldBankAccount:
		return m.BankAccount()
	case merchantstore.FieldMomoAccount:
		return m.MomoAccount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantStoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchantstore.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case merchantstore.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case merchantstore.FieldName:
		return m.OldName(ctx)
	case merchantstore.FieldAbout:
		return m.OldAbout(ctx)
	case merchantstore.FieldDescTitle:
		return m.OldDescTitle(ctx)
	case merchantstore.FieldDescription:
		return m.OldDescription(ctx)
	case merchantstore.FieldLogo:
		return m.OldLogo(ctx)
	case merchantstore.FieldImages:
		return m.OldImages(ctx)
	case merchantstore.FieldDefaultAccount:
		return m.OldDefaultAccount(ctx)
	case merchantstore.FieldBankAccount:
		return m.OldBankAccount(ctx)
	case merchantstore.FieldMomoAccount:
		return m.OldMomoAccount(ctx)
	}
	return nil, fmt.Errorf("unknown MerchantStore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantStoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchantstore.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case merchantstore.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case merchantstore.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case merchantstore.FieldAbout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbout(v)
		return nil
	case merchantstore.FieldDescTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescTitle(v)
		return nil
	case merchantstore.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case merchantstore.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case merchantstore.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case merchantstore.FieldDefaultAccount:
		v, ok := value.(merchantstore.DefaultAccount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultAccount(v)
		return nil
	case merchantstore.FieldBankAccount:
		v, ok := value.(*models.MerchantBankAccount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccount(v)
		return nil
	case merchantstore.FieldMomoAccount:
		v, ok := value.(*models.MerchantMomoAccount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMomoAccount(v)
		return nil
	}
	return fmt.Errorf("unknown MerchantStore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantStoreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantStoreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantStoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MerchantStore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantStoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(merchantstore.FieldImages) {
		fields = append(fields, merchantstore.FieldImages)
	}
	if m.FieldCleared(merchantstore.FieldDefaultAccount) {
		fields = append(fields, merchantstore.FieldDefaultAccount)
	}
	if m.FieldCleared(merchantstore.FieldBankAccount) {
		fields = append(fields, merchantstore.FieldBankAccount)
	}
	if m.FieldCleared(merchantstore.FieldMomoAccount) {
		fields = append(fields, merchantstore.FieldMomoAccount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantStoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantStoreMutation) ClearField(name string) error {
	switch name {
	case merchantstore.FieldImages:
		m.ClearImages()
		return nil
	case merchantstore.FieldDefaultAccount:
		m.ClearDefaultAccount()
		return nil
	case merchantstore.FieldBankAccount:
		m.ClearBankAccount()
		return nil
	case merchantstore.FieldMomoAccount:
		m.ClearMomoAccount()
		return nil
	}
	return fmt.Errorf("unknown MerchantStore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantStoreMutation) ResetField(name string) error {
	switch name {
	case merchantstore.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case merchantstore.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case merchantstore.FieldName:
		m.ResetName()
		return nil
	case merchantstore.FieldAbout:
		m.ResetAbout()
		return nil
	case merchantstore.FieldDescTitle:
		m.ResetDescTitle()
		return nil
	case merchantstore.FieldDescription:
		m.ResetDescription()
		return nil
	case merchantstore.FieldLogo:
		m.ResetLogo()
		return nil
	case merchantstore.FieldImages:
		m.ResetImages()
		return nil
	case merchantstore.FieldDefaultAccount:
		m.ResetDefaultAccount()
		return nil
	case merchantstore.FieldBankAccount:
		m.ResetBankAccount()
		return nil
	case merchantstore.FieldMomoAccount:
		m.ResetMomoAccount()
		return nil
	}
	return fmt.Errorf("unknown MerchantStore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantStoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.merchant != nil {
		edges = append(edges, merchantstore.EdgeMerchant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantStoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case merchantstore.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantStoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantStoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantStoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmerchant {
		edges = append(edges, merchantstore.EdgeMerchant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantStoreMutation) EdgeCleared(name string) bool {
	switch name {
	case merchantstore.EdgeMerchant:
		return m.clearedmerchant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantStoreMutation) ClearEdge(name string) error {
	switch name {
	case merchantstore.EdgeMerchant:
		m.ClearMerchant()
		return nil
	}
	return fmt.Errorf("unknown MerchantStore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantStoreMutation) ResetEdge(name string) error {
	switch name {
	case merchantstore.EdgeMerchant:
		m.ResetMerchant()
		return nil
	}
	return fmt.Errorf("unknown MerchantStore edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	status          *order.Status
	delivered_at    *time.Time
	clearedFields   map[string]struct{}
	merchant        *int
	clearedmerchant bool
	agent           *int
	clearedagent    bool
	customer        *int
	clearedcustomer bool
	address         *int
	clearedaddress  bool
	product         *int
	clearedproduct  bool
	done            bool
	oldValue        func(context.Context) (*Order, error)
	predicates      []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetDeliveredAt sets the "delivered_at" field.
func (m *OrderMutation) SetDeliveredAt(t time.Time) {
	m.delivered_at = &t
}

// DeliveredAt returns the value of the "delivered_at" field in the mutation.
func (m *OrderMutation) DeliveredAt() (r time.Time, exists bool) {
	v := m.delivered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveredAt returns the old "delivered_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeliveredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveredAt: %w", err)
	}
	return oldValue.DeliveredAt, nil
}

// ClearDeliveredAt clears the value of the "delivered_at" field.
func (m *OrderMutation) ClearDeliveredAt() {
	m.delivered_at = nil
	m.clearedFields[order.FieldDeliveredAt] = struct{}{}
}

// DeliveredAtCleared returns if the "delivered_at" field was cleared in this mutation.
func (m *OrderMutation) DeliveredAtCleared() bool {
	_, ok := m.clearedFields[order.FieldDeliveredAt]
	return ok
}

// ResetDeliveredAt resets all changes to the "delivered_at" field.
func (m *OrderMutation) ResetDeliveredAt() {
	m.delivered_at = nil
	delete(m.clearedFields, order.FieldDeliveredAt)
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *OrderMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *OrderMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *OrderMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *OrderMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *OrderMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetAgentID sets the "agent" edge to the Agent entity by id.
func (m *OrderMutation) SetAgentID(id int) {
	m.agent = &id
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *OrderMutation) ClearAgent() {
	m.clearedagent = true
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *OrderMutation) AgentCleared() bool {
	return m.clearedagent
}

// AgentID returns the "agent" edge ID in the mutation.
func (m *OrderMutation) AgentID() (id int, exists bool) {
	if m.agent != nil {
		return *m.agent, true
	}
	return
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) AgentIDs() (ids []int) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *OrderMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *OrderMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *OrderMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *OrderMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *OrderMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *OrderMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetAddressID sets the "address" edge to the Address entity by id.
func (m *OrderMutation) SetAddressID(id int) {
	m.address = &id
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *OrderMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *OrderMutation) AddressCleared() bool {
	return m.clearedaddress
}

// AddressID returns the "address" edge ID in the mutation.
func (m *OrderMutation) AddressID() (id int, exists bool) {
	if m.address != nil {
		return *m.address, true
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) AddressIDs() (ids []int) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *OrderMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *OrderMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *OrderMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *OrderMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *OrderMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *OrderMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.delivered_at != nil {
		fields = append(fields, order.FieldDeliveredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldStatus:
		return m.Status()
	case order.FieldDeliveredAt:
		return m.DeliveredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldDeliveredAt:
		return m.OldDeliveredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldDeliveredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldDeliveredAt) {
		fields = append(fields, order.FieldDeliveredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldDeliveredAt:
		m.ClearDeliveredAt()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldDeliveredAt:
		m.ResetDeliveredAt()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.merchant != nil {
		edges = append(edges, order.EdgeMerchant)
	}
	if m.agent != nil {
		edges = append(edges, order.EdgeAgent)
	}
	if m.customer != nil {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.address != nil {
		edges = append(edges, order.EdgeAddress)
	}
	if m.product != nil {
		edges = append(edges, order.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedmerchant {
		edges = append(edges, order.EdgeMerchant)
	}
	if m.clearedagent {
		edges = append(edges, order.EdgeAgent)
	}
	if m.clearedcustomer {
		edges = append(edges, order.EdgeCustomer)
	}
	if m.clearedaddress {
		edges = append(edges, order.EdgeAddress)
	}
	if m.clearedproduct {
		edges = append(edges, order.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeMerchant:
		return m.clearedmerchant
	case order.EdgeAgent:
		return m.clearedagent
	case order.EdgeCustomer:
		return m.clearedcustomer
	case order.EdgeAddress:
		return m.clearedaddress
	case order.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case order.EdgeAgent:
		m.ClearAgent()
		return nil
	case order.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case order.EdgeAddress:
		m.ClearAddress()
		return nil
	case order.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case order.EdgeAgent:
		m.ResetAgent()
		return nil
	case order.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case order.EdgeAddress:
		m.ResetAddress()
		return nil
	case order.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	price             *float64
	addprice          *float64
	promo_price       *float64
	addpromo_price    *float64
	quantity          *uint32
	addquantity       *int32
	unit              *string
	description       *string
	image             *string
	clearedFields     map[string]struct{}
	merchant          *int
	clearedmerchant   bool
	major             *int
	clearedmajor      bool
	minor             *int
	clearedminor      bool
	orders            map[int]struct{}
	removedorders     map[int]struct{}
	clearedorders     bool
	baskets           map[int]struct{}
	removedbaskets    map[int]struct{}
	clearedbaskets    bool
	favourites        map[int]struct{}
	removedfavourites map[int]struct{}
	clearedfavourites bool
	done              bool
	oldValue          func(context.Context) (*Product, error)
	predicates        []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetPromoPrice sets the "promo_price" field.
func (m *ProductMutation) SetPromoPrice(f float64) {
	m.promo_price = &f
	m.addpromo_price = nil
}

// PromoPrice returns the value of the "promo_price" field in the mutation.
func (m *ProductMutation) PromoPrice() (r float64, exists bool) {
	v := m.promo_price
	if v == nil {
		return
	}
	return *v, true
}

// OldPromoPrice returns the old "promo_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPromoPrice(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromoPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromoPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromoPrice: %w", err)
	}
	return oldValue.PromoPrice, nil
}

// AddPromoPrice adds f to the "promo_price" field.
func (m *ProductMutation) AddPromoPrice(f float64) {
	if m.addpromo_price != nil {
		*m.addpromo_price += f
	} else {
		m.addpromo_price = &f
	}
}

// AddedPromoPrice returns the value that was added to the "promo_price" field in this mutation.
func (m *ProductMutation) AddedPromoPrice() (r float64, exists bool) {
	v := m.addpromo_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromoPrice clears the value of the "promo_price" field.
func (m *ProductMutation) ClearPromoPrice() {
	m.promo_price = nil
	m.addpromo_price = nil
	m.clearedFields[product.FieldPromoPrice] = struct{}{}
}

// PromoPriceCleared returns if the "promo_price" field was cleared in this mutation.
func (m *ProductMutation) PromoPriceCleared() bool {
	_, ok := m.clearedFields[product.FieldPromoPrice]
	return ok
}

// ResetPromoPrice resets all changes to the "promo_price" field.
func (m *ProductMutation) ResetPromoPrice() {
	m.promo_price = nil
	m.addpromo_price = nil
	delete(m.clearedFields, product.FieldPromoPrice)
}

// SetQuantity sets the "quantity" field.
func (m *ProductMutation) SetQuantity(u uint32) {
	m.quantity = &u
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ProductMutation) Quantity() (r uint32, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldQuantity(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds u to the "quantity" field.
func (m *ProductMutation) AddQuantity(u int32) {
	if m.addquantity != nil {
		*m.addquantity += u
	} else {
		m.addquantity = &u
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ProductMutation) AddedQuantity() (r int32, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ProductMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnit sets the "unit" field.
func (m *ProductMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *ProductMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *ProductMutation) ResetUnit() {
	m.unit = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
}

// SetImage sets the "image" field.
func (m *ProductMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ProductMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *ProductMutation) ResetImage() {
	m.image = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *ProductMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *ProductMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *ProductMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *ProductMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *ProductMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// SetMajorID sets the "major" edge to the ProductCategoryMajor entity by id.
func (m *ProductMutation) SetMajorID(id int) {
	m.major = &id
}

// ClearMajor clears the "major" edge to the ProductCategoryMajor entity.
func (m *ProductMutation) ClearMajor() {
	m.clearedmajor = true
}

// MajorCleared reports if the "major" edge to the ProductCategoryMajor entity was cleared.
func (m *ProductMutation) MajorCleared() bool {
	return m.clearedmajor
}

// MajorID returns the "major" edge ID in the mutation.
func (m *ProductMutation) MajorID() (id int, exists bool) {
	if m.major != nil {
		return *m.major, true
	}
	return
}

// MajorIDs returns the "major" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) MajorIDs() (ids []int) {
	if id := m.major; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajor resets all changes to the "major" edge.
func (m *ProductMutation) ResetMajor() {
	m.major = nil
	m.clearedmajor = false
}

// SetMinorID sets the "minor" edge to the ProductCategoryMinor entity by id.
func (m *ProductMutation) SetMinorID(id int) {
	m.minor = &id
}

// ClearMinor clears the "minor" edge to the ProductCategoryMinor entity.
func (m *ProductMutation) ClearMinor() {
	m.clearedminor = true
}

// MinorCleared reports if the "minor" edge to the ProductCategoryMinor entity was cleared.
func (m *ProductMutation) MinorCleared() bool {
	return m.clearedminor
}

// MinorID returns the "minor" edge ID in the mutation.
func (m *ProductMutation) MinorID() (id int, exists bool) {
	if m.minor != nil {
		return *m.minor, true
	}
	return
}

// MinorIDs returns the "minor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MinorID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) MinorIDs() (ids []int) {
	if id := m.minor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMinor resets all changes to the "minor" edge.
func (m *ProductMutation) ResetMinor() {
	m.minor = nil
	m.clearedminor = false
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *ProductMutation) AddOrderIDs(ids ...int) {
	if m.orders == nil {
		m.orders = make(map[int]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *ProductMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *ProductMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *ProductMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorders == nil {
		m.removedorders = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *ProductMutation) RemovedOrdersIDs() (ids []int) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *ProductMutation) OrdersIDs() (ids []int) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *ProductMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddBasketIDs adds the "baskets" edge to the Basket entity by ids.
func (m *ProductMutation) AddBasketIDs(ids ...int) {
	if m.baskets == nil {
		m.baskets = make(map[int]struct{})
	}
	for i := range ids {
		m.baskets[ids[i]] = struct{}{}
	}
}

// ClearBaskets clears the "baskets" edge to the Basket entity.
func (m *ProductMutation) ClearBaskets() {
	m.clearedbaskets = true
}

// BasketsCleared reports if the "baskets" edge to the Basket entity was cleared.
func (m *ProductMutation) BasketsCleared() bool {
	return m.clearedbaskets
}

// RemoveBasketIDs removes the "baskets" edge to the Basket entity by IDs.
func (m *ProductMutation) RemoveBasketIDs(ids ...int) {
	if m.removedbaskets == nil {
		m.removedbaskets = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baskets, ids[i])
		m.removedbaskets[ids[i]] = struct{}{}
	}
}

// RemovedBaskets returns the removed IDs of the "baskets" edge to the Basket entity.
func (m *ProductMutation) RemovedBasketsIDs() (ids []int) {
	for id := range m.removedbaskets {
		ids = append(ids, id)
	}
	return
}

// BasketsIDs returns the "baskets" edge IDs in the mutation.
func (m *ProductMutation) BasketsIDs() (ids []int) {
	for id := range m.baskets {
		ids = append(ids, id)
	}
	return
}

// ResetBaskets resets all changes to the "baskets" edge.
func (m *ProductMutation) ResetBaskets() {
	m.baskets = nil
	m.clearedbaskets = false
	m.removedbaskets = nil
}

// AddFavouriteIDs adds the "favourites" edge to the Favourite entity by ids.
func (m *ProductMutation) AddFavouriteIDs(ids ...int) {
	if m.favourites == nil {
		m.favourites = make(map[int]struct{})
	}
	for i := range ids {
		m.favourites[ids[i]] = struct{}{}
	}
}

// ClearFavourites clears the "favourites" edge to the Favourite entity.
func (m *ProductMutation) ClearFavourites() {
	m.clearedfavourites = true
}

// FavouritesCleared reports if the "favourites" edge to the Favourite entity was cleared.
func (m *ProductMutation) FavouritesCleared() bool {
	return m.clearedfavourites
}

// RemoveFavouriteIDs removes the "favourites" edge to the Favourite entity by IDs.
func (m *ProductMutation) RemoveFavouriteIDs(ids ...int) {
	if m.removedfavourites == nil {
		m.removedfavourites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favourites, ids[i])
		m.removedfavourites[ids[i]] = struct{}{}
	}
}

// RemovedFavourites returns the removed IDs of the "favourites" edge to the Favourite entity.
func (m *ProductMutation) RemovedFavouritesIDs() (ids []int) {
	for id := range m.removedfavourites {
		ids = append(ids, id)
	}
	return
}

// FavouritesIDs returns the "favourites" edge IDs in the mutation.
func (m *ProductMutation) FavouritesIDs() (ids []int) {
	for id := range m.favourites {
		ids = append(ids, id)
	}
	return
}

// ResetFavourites resets all changes to the "favourites" edge.
func (m *ProductMutation) ResetFavourites() {
	m.favourites = nil
	m.clearedfavourites = false
	m.removedfavourites = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.promo_price != nil {
		fields = append(fields, product.FieldPromoPrice)
	}
	if m.quantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	if m.unit != nil {
		fields = append(fields, product.FieldUnit)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.image != nil {
		fields = append(fields, product.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldName:
		return m.Name()
	case product.FieldPrice:
		return m.Price()
	case product.FieldPromoPrice:
		return m.PromoPrice()
	case product.FieldQuantity:
		return m.Quantity()
	case product.FieldUnit:
		return m.Unit()
	case product.FieldDescription:
		return m.Description()
	case product.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldPromoPrice:
		return m.OldPromoPrice(ctx)
	case product.FieldQuantity:
		return m.OldQuantity(ctx)
	case product.FieldUnit:
		return m.OldUnit(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldPromoPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromoPrice(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case product.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.addpromo_price != nil {
		fields = append(fields, product.FieldPromoPrice)
	}
	if m.addquantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldPrice:
		return m.AddedPrice()
	case product.FieldPromoPrice:
		return m.AddedPromoPrice()
	case product.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case product.FieldPromoPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromoPrice(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldPromoPrice) {
		fields = append(fields, product.FieldPromoPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldPromoPrice:
		m.ClearPromoPrice()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldPromoPrice:
		m.ResetPromoPrice()
		return nil
	case product.FieldQuantity:
		m.ResetQuantity()
		return nil
	case product.FieldUnit:
		m.ResetUnit()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.merchant != nil {
		edges = append(edges, product.EdgeMerchant)
	}
	if m.major != nil {
		edges = append(edges, product.EdgeMajor)
	}
	if m.minor != nil {
		edges = append(edges, product.EdgeMinor)
	}
	if m.orders != nil {
		edges = append(edges, product.EdgeOrders)
	}
	if m.baskets != nil {
		edges = append(edges, product.EdgeBaskets)
	}
	if m.favourites != nil {
		edges = append(edges, product.EdgeFavourites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeMajor:
		if id := m.major; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeMinor:
		if id := m.minor; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeBaskets:
		ids := make([]ent.Value, 0, len(m.baskets))
		for id := range m.baskets {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.favourites))
		for id := range m.favourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedorders != nil {
		edges = append(edges, product.EdgeOrders)
	}
	if m.removedbaskets != nil {
		edges = append(edges, product.EdgeBaskets)
	}
	if m.removedfavourites != nil {
		edges = append(edges, product.EdgeFavourites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeBaskets:
		ids := make([]ent.Value, 0, len(m.removedbaskets))
		for id := range m.removedbaskets {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeFavourites:
		ids := make([]ent.Value, 0, len(m.removedfavourites))
		for id := range m.removedfavourites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedmerchant {
		edges = append(edges, product.EdgeMerchant)
	}
	if m.clearedmajor {
		edges = append(edges, product.EdgeMajor)
	}
	if m.clearedminor {
		edges = append(edges, product.EdgeMinor)
	}
	if m.clearedorders {
		edges = append(edges, product.EdgeOrders)
	}
	if m.clearedbaskets {
		edges = append(edges, product.EdgeBaskets)
	}
	if m.clearedfavourites {
		edges = append(edges, product.EdgeFavourites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeMerchant:
		return m.clearedmerchant
	case product.EdgeMajor:
		return m.clearedmajor
	case product.EdgeMinor:
		return m.clearedminor
	case product.EdgeOrders:
		return m.clearedorders
	case product.EdgeBaskets:
		return m.clearedbaskets
	case product.EdgeFavourites:
		return m.clearedfavourites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeMerchant:
		m.ClearMerchant()
		return nil
	case product.EdgeMajor:
		m.ClearMajor()
		return nil
	case product.EdgeMinor:
		m.ClearMinor()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeMerchant:
		m.ResetMerchant()
		return nil
	case product.EdgeMajor:
		m.ResetMajor()
		return nil
	case product.EdgeMinor:
		m.ResetMinor()
		return nil
	case product.EdgeOrders:
		m.ResetOrders()
		return nil
	case product.EdgeBaskets:
		m.ResetBaskets()
		return nil
	case product.EdgeFavourites:
		m.ResetFavourites()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductCategoryMajorMutation represents an operation that mutates the ProductCategoryMajor nodes in the graph.
type ProductCategoryMajorMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	category        *string
	sulg            *string
	clearedFields   map[string]struct{}
	minors          map[int]struct{}
	removedminors   map[int]struct{}
	clearedminors   bool
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*ProductCategoryMajor, error)
	predicates      []predicate.ProductCategoryMajor
}

var _ ent.Mutation = (*ProductCategoryMajorMutation)(nil)

// productcategorymajorOption allows management of the mutation configuration using functional options.
type productcategorymajorOption func(*ProductCategoryMajorMutation)

// newProductCategoryMajorMutation creates new mutation for the ProductCategoryMajor entity.
func newProductCategoryMajorMutation(c config, op Op, opts ...productcategorymajorOption) *ProductCategoryMajorMutation {
	m := &ProductCategoryMajorMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategoryMajor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryMajorID sets the ID field of the mutation.
func withProductCategoryMajorID(id int) productcategorymajorOption {
	return func(m *ProductCategoryMajorMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategoryMajor
		)
		m.oldValue = func(ctx context.Context) (*ProductCategoryMajor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategoryMajor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategoryMajor sets the old ProductCategoryMajor of the mutation.
func withProductCategoryMajor(node *ProductCategoryMajor) productcategorymajorOption {
	return func(m *ProductCategoryMajorMutation) {
		m.oldValue = func(context.Context) (*ProductCategoryMajor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryMajorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryMajorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCategoryMajorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductCategoryMajorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductCategoryMajor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductCategoryMajorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductCategoryMajorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductCategoryMajor entity.
// If the ProductCategoryMajor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMajorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductCategoryMajorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductCategoryMajorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductCategoryMajorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductCategoryMajor entity.
// If the ProductCategoryMajor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMajorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductCategoryMajorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCategory sets the "category" field.
func (m *ProductCategoryMajorMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProductCategoryMajorMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ProductCategoryMajor entity.
// If the ProductCategoryMajor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMajorMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ProductCategoryMajorMutation) ResetCategory() {
	m.category = nil
}

// SetSulg sets the "sulg" field.
func (m *ProductCategoryMajorMutation) SetSulg(s string) {
	m.sulg = &s
}

// Sulg returns the value of the "sulg" field in the mutation.
func (m *ProductCategoryMajorMutation) Sulg() (r string, exists bool) {
	v := m.sulg
	if v == nil {
		return
	}
	return *v, true
}

// OldSulg returns the old "sulg" field's value of the ProductCategoryMajor entity.
// If the ProductCategoryMajor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMajorMutation) OldSulg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSulg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSulg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSulg: %w", err)
	}
	return oldValue.Sulg, nil
}

// ResetSulg resets all changes to the "sulg" field.
func (m *ProductCategoryMajorMutation) ResetSulg() {
	m.sulg = nil
}

// AddMinorIDs adds the "minors" edge to the ProductCategoryMinor entity by ids.
func (m *ProductCategoryMajorMutation) AddMinorIDs(ids ...int) {
	if m.minors == nil {
		m.minors = make(map[int]struct{})
	}
	for i := range ids {
		m.minors[ids[i]] = struct{}{}
	}
}

// ClearMinors clears the "minors" edge to the ProductCategoryMinor entity.
func (m *ProductCategoryMajorMutation) ClearMinors() {
	m.clearedminors = true
}

// MinorsCleared reports if the "minors" edge to the ProductCategoryMinor entity was cleared.
func (m *ProductCategoryMajorMutation) MinorsCleared() bool {
	return m.clearedminors
}

// RemoveMinorIDs removes the "minors" edge to the ProductCategoryMinor entity by IDs.
func (m *ProductCategoryMajorMutation) RemoveMinorIDs(ids ...int) {
	if m.removedminors == nil {
		m.removedminors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.minors, ids[i])
		m.removedminors[ids[i]] = struct{}{}
	}
}

// RemovedMinors returns the removed IDs of the "minors" edge to the ProductCategoryMinor entity.
func (m *ProductCategoryMajorMutation) RemovedMinorsIDs() (ids []int) {
	for id := range m.removedminors {
		ids = append(ids, id)
	}
	return
}

// MinorsIDs returns the "minors" edge IDs in the mutation.
func (m *ProductCategoryMajorMutation) MinorsIDs() (ids []int) {
	for id := range m.minors {
		ids = append(ids, id)
	}
	return
}

// ResetMinors resets all changes to the "minors" edge.
func (m *ProductCategoryMajorMutation) ResetMinors() {
	m.minors = nil
	m.clearedminors = false
	m.removedminors = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ProductCategoryMajorMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductCategoryMajorMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductCategoryMajorMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ProductCategoryMajorMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ProductCategoryMajorMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductCategoryMajorMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductCategoryMajorMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ProductCategoryMajorMutation builder.
func (m *ProductCategoryMajorMutation) Where(ps ...predicate.ProductCategoryMajor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductCategoryMajorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductCategoryMajor).
func (m *ProductCategoryMajorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryMajorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, productcategorymajor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productcategorymajor.FieldUpdatedAt)
	}
	if m.category != nil {
		fields = append(fields, productcategorymajor.FieldCategory)
	}
	if m.sulg != nil {
		fields = append(fields, productcategorymajor.FieldSulg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryMajorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategorymajor.FieldCreatedAt:
		return m.CreatedAt()
	case productcategorymajor.FieldUpdatedAt:
		return m.UpdatedAt()
	case productcategorymajor.FieldCategory:
		return m.Category()
	case productcategorymajor.FieldSulg:
		return m.Sulg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryMajorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategorymajor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productcategorymajor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productcategorymajor.FieldCategory:
		return m.OldCategory(ctx)
	case productcategorymajor.FieldSulg:
		return m.OldSulg(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategoryMajor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMajorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategorymajor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productcategorymajor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productcategorymajor.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case productcategorymajor.FieldSulg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSulg(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMajor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryMajorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryMajorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMajorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategoryMajor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryMajorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryMajorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryMajorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductCategoryMajor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryMajorMutation) ResetField(name string) error {
	switch name {
	case productcategorymajor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productcategorymajor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productcategorymajor.FieldCategory:
		m.ResetCategory()
		return nil
	case productcategorymajor.FieldSulg:
		m.ResetSulg()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMajor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryMajorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.minors != nil {
		edges = append(edges, productcategorymajor.EdgeMinors)
	}
	if m.products != nil {
		edges = append(edges, productcategorymajor.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryMajorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcategorymajor.EdgeMinors:
		ids := make([]ent.Value, 0, len(m.minors))
		for id := range m.minors {
			ids = append(ids, id)
		}
		return ids
	case productcategorymajor.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryMajorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedminors != nil {
		edges = append(edges, productcategorymajor.EdgeMinors)
	}
	if m.removedproducts != nil {
		edges = append(edges, productcategorymajor.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryMajorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcategorymajor.EdgeMinors:
		ids := make([]ent.Value, 0, len(m.removedminors))
		for id := range m.removedminors {
			ids = append(ids, id)
		}
		return ids
	case productcategorymajor.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryMajorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedminors {
		edges = append(edges, productcategorymajor.EdgeMinors)
	}
	if m.clearedproducts {
		edges = append(edges, productcategorymajor.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryMajorMutation) EdgeCleared(name string) bool {
	switch name {
	case productcategorymajor.EdgeMinors:
		return m.clearedminors
	case productcategorymajor.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryMajorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategoryMajor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryMajorMutation) ResetEdge(name string) error {
	switch name {
	case productcategorymajor.EdgeMinors:
		m.ResetMinors()
		return nil
	case productcategorymajor.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMajor edge %s", name)
}

// ProductCategoryMinorMutation represents an operation that mutates the ProductCategoryMinor nodes in the graph.
type ProductCategoryMinorMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	category        *string
	image           *string
	sulg            *string
	clearedFields   map[string]struct{}
	major           *int
	clearedmajor    bool
	products        map[int]struct{}
	removedproducts map[int]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*ProductCategoryMinor, error)
	predicates      []predicate.ProductCategoryMinor
}

var _ ent.Mutation = (*ProductCategoryMinorMutation)(nil)

// productcategoryminorOption allows management of the mutation configuration using functional options.
type productcategoryminorOption func(*ProductCategoryMinorMutation)

// newProductCategoryMinorMutation creates new mutation for the ProductCategoryMinor entity.
func newProductCategoryMinorMutation(c config, op Op, opts ...productcategoryminorOption) *ProductCategoryMinorMutation {
	m := &ProductCategoryMinorMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategoryMinor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryMinorID sets the ID field of the mutation.
func withProductCategoryMinorID(id int) productcategoryminorOption {
	return func(m *ProductCategoryMinorMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategoryMinor
		)
		m.oldValue = func(ctx context.Context) (*ProductCategoryMinor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategoryMinor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategoryMinor sets the old ProductCategoryMinor of the mutation.
func withProductCategoryMinor(node *ProductCategoryMinor) productcategoryminorOption {
	return func(m *ProductCategoryMinorMutation) {
		m.oldValue = func(context.Context) (*ProductCategoryMinor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryMinorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryMinorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCategoryMinorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductCategoryMinorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductCategoryMinor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductCategoryMinorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductCategoryMinorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductCategoryMinor entity.
// If the ProductCategoryMinor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMinorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductCategoryMinorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductCategoryMinorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductCategoryMinorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductCategoryMinor entity.
// If the ProductCategoryMinor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMinorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductCategoryMinorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCategory sets the "category" field.
func (m *ProductCategoryMinorMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProductCategoryMinorMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ProductCategoryMinor entity.
// If the ProductCategoryMinor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMinorMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ProductCategoryMinorMutation) ResetCategory() {
	m.category = nil
}

// SetImage sets the "image" field.
func (m *ProductCategoryMinorMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ProductCategoryMinorMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the ProductCategoryMinor entity.
// If the ProductCategoryMinor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMinorMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *ProductCategoryMinorMutation) ResetImage() {
	m.image = nil
}

// SetSulg sets the "sulg" field.
func (m *ProductCategoryMinorMutation) SetSulg(s string) {
	m.sulg = &s
}

// Sulg returns the value of the "sulg" field in the mutation.
func (m *ProductCategoryMinorMutation) Sulg() (r string, exists bool) {
	v := m.sulg
	if v == nil {
		return
	}
	return *v, true
}

// OldSulg returns the old "sulg" field's value of the ProductCategoryMinor entity.
// If the ProductCategoryMinor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMinorMutation) OldSulg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSulg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSulg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSulg: %w", err)
	}
	return oldValue.Sulg, nil
}

// ResetSulg resets all changes to the "sulg" field.
func (m *ProductCategoryMinorMutation) ResetSulg() {
	m.sulg = nil
}

// SetMajorID sets the "major" edge to the ProductCategoryMajor entity by id.
func (m *ProductCategoryMinorMutation) SetMajorID(id int) {
	m.major = &id
}

// ClearMajor clears the "major" edge to the ProductCategoryMajor entity.
func (m *ProductCategoryMinorMutation) ClearMajor() {
	m.clearedmajor = true
}

// MajorCleared reports if the "major" edge to the ProductCategoryMajor entity was cleared.
func (m *ProductCategoryMinorMutation) MajorCleared() bool {
	return m.clearedmajor
}

// MajorID returns the "major" edge ID in the mutation.
func (m *ProductCategoryMinorMutation) MajorID() (id int, exists bool) {
	if m.major != nil {
		return *m.major, true
	}
	return
}

// MajorIDs returns the "major" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MajorID instead. It exists only for internal usage by the builders.
func (m *ProductCategoryMinorMutation) MajorIDs() (ids []int) {
	if id := m.major; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMajor resets all changes to the "major" edge.
func (m *ProductCategoryMinorMutation) ResetMajor() {
	m.major = nil
	m.clearedmajor = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ProductCategoryMinorMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductCategoryMinorMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductCategoryMinorMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ProductCategoryMinorMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ProductCategoryMinorMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductCategoryMinorMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductCategoryMinorMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ProductCategoryMinorMutation builder.
func (m *ProductCategoryMinorMutation) Where(ps ...predicate.ProductCategoryMinor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductCategoryMinorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductCategoryMinor).
func (m *ProductCategoryMinorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryMinorMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, productcategoryminor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productcategoryminor.FieldUpdatedAt)
	}
	if m.category != nil {
		fields = append(fields, productcategoryminor.FieldCategory)
	}
	if m.image != nil {
		fields = append(fields, productcategoryminor.FieldImage)
	}
	if m.sulg != nil {
		fields = append(fields, productcategoryminor.FieldSulg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryMinorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategoryminor.FieldCreatedAt:
		return m.CreatedAt()
	case productcategoryminor.FieldUpdatedAt:
		return m.UpdatedAt()
	case productcategoryminor.FieldCategory:
		return m.Category()
	case productcategoryminor.FieldImage:
		return m.Image()
	case productcategoryminor.FieldSulg:
		return m.Sulg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryMinorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategoryminor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productcategoryminor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productcategoryminor.FieldCategory:
		return m.OldCategory(ctx)
	case productcategoryminor.FieldImage:
		return m.OldImage(ctx)
	case productcategoryminor.FieldSulg:
		return m.OldSulg(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategoryMinor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMinorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategoryminor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productcategoryminor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productcategoryminor.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case productcategoryminor.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case productcategoryminor.FieldSulg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSulg(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMinor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryMinorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryMinorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMinorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategoryMinor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryMinorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryMinorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryMinorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProductCategoryMinor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryMinorMutation) ResetField(name string) error {
	switch name {
	case productcategoryminor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productcategoryminor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productcategoryminor.FieldCategory:
		m.ResetCategory()
		return nil
	case productcategoryminor.FieldImage:
		m.ResetImage()
		return nil
	case productcategoryminor.FieldSulg:
		m.ResetSulg()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMinor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryMinorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.major != nil {
		edges = append(edges, productcategoryminor.EdgeMajor)
	}
	if m.products != nil {
		edges = append(edges, productcategoryminor.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryMinorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcategoryminor.EdgeMajor:
		if id := m.major; id != nil {
			return []ent.Value{*id}
		}
	case productcategoryminor.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryMinorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproducts != nil {
		edges = append(edges, productcategoryminor.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryMinorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcategoryminor.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryMinorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmajor {
		edges = append(edges, productcategoryminor.EdgeMajor)
	}
	if m.clearedproducts {
		edges = append(edges, productcategoryminor.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryMinorMutation) EdgeCleared(name string) bool {
	switch name {
	case productcategoryminor.EdgeMajor:
		return m.clearedmajor
	case productcategoryminor.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryMinorMutation) ClearEdge(name string) error {
	switch name {
	case productcategoryminor.EdgeMajor:
		m.ClearMajor()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMinor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryMinorMutation) ResetEdge(name string) error {
	switch name {
	case productcategoryminor.EdgeMajor:
		m.ResetMajor()
		return nil
	case productcategoryminor.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryMinor edge %s", name)
}

// RetailMerchantMutation represents an operation that mutates the RetailMerchant nodes in the graph.
type RetailMerchantMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	ghana_card      *string
	last_name       *string
	other_name      *string
	phone           *string
	other_phone     *string
	address         *string
	digital_address *string
	clearedFields   map[string]struct{}
	merchant        *int
	clearedmerchant bool
	done            bool
	oldValue        func(context.Context) (*RetailMerchant, error)
	predicates      []predicate.RetailMerchant
}

var _ ent.Mutation = (*RetailMerchantMutation)(nil)

// retailmerchantOption allows management of the mutation configuration using functional options.
type retailmerchantOption func(*RetailMerchantMutation)

// newRetailMerchantMutation creates new mutation for the RetailMerchant entity.
func newRetailMerchantMutation(c config, op Op, opts ...retailmerchantOption) *RetailMerchantMutation {
	m := &RetailMerchantMutation{
		config:        c,
		op:            op,
		typ:           TypeRetailMerchant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRetailMerchantID sets the ID field of the mutation.
func withRetailMerchantID(id int) retailmerchantOption {
	return func(m *RetailMerchantMutation) {
		var (
			err   error
			once  sync.Once
			value *RetailMerchant
		)
		m.oldValue = func(ctx context.Context) (*RetailMerchant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RetailMerchant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRetailMerchant sets the old RetailMerchant of the mutation.
func withRetailMerchant(node *RetailMerchant) retailmerchantOption {
	return func(m *RetailMerchantMutation) {
		m.oldValue = func(context.Context) (*RetailMerchant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RetailMerchantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RetailMerchantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RetailMerchantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RetailMerchantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RetailMerchant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RetailMerchantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RetailMerchantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RetailMerchantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RetailMerchantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RetailMerchantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RetailMerchantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGhanaCard sets the "ghana_card" field.
func (m *RetailMerchantMutation) SetGhanaCard(s string) {
	m.ghana_card = &s
}

// GhanaCard returns the value of the "ghana_card" field in the mutation.
func (m *RetailMerchantMutation) GhanaCard() (r string, exists bool) {
	v := m.ghana_card
	if v == nil {
		return
	}
	return *v, true
}

// OldGhanaCard returns the old "ghana_card" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldGhanaCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGhanaCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGhanaCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGhanaCard: %w", err)
	}
	return oldValue.GhanaCard, nil
}

// ResetGhanaCard resets all changes to the "ghana_card" field.
func (m *RetailMerchantMutation) ResetGhanaCard() {
	m.ghana_card = nil
}

// SetLastName sets the "last_name" field.
func (m *RetailMerchantMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *RetailMerchantMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *RetailMerchantMutation) ResetLastName() {
	m.last_name = nil
}

// SetOtherName sets the "other_name" field.
func (m *RetailMerchantMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *RetailMerchantMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *RetailMerchantMutation) ResetOtherName() {
	m.other_name = nil
}

// SetPhone sets the "phone" field.
func (m *RetailMerchantMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *RetailMerchantMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *RetailMerchantMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *RetailMerchantMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *RetailMerchantMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldOtherPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *RetailMerchantMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[retailmerchant.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *RetailMerchantMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[retailmerchant.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *RetailMerchantMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, retailmerchant.FieldOtherPhone)
}

// SetAddress sets the "address" field.
func (m *RetailMerchantMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *RetailMerchantMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *RetailMerchantMutation) ResetAddress() {
	m.address = nil
}

// SetDigitalAddress sets the "digital_address" field.
func (m *RetailMerchantMutation) SetDigitalAddress(s string) {
	m.digital_address = &s
}

// DigitalAddress returns the value of the "digital_address" field in the mutation.
func (m *RetailMerchantMutation) DigitalAddress() (r string, exists bool) {
	v := m.digital_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDigitalAddress returns the old "digital_address" field's value of the RetailMerchant entity.
// If the RetailMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RetailMerchantMutation) OldDigitalAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigitalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigitalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigitalAddress: %w", err)
	}
	return oldValue.DigitalAddress, nil
}

// ResetDigitalAddress resets all changes to the "digital_address" field.
func (m *RetailMerchantMutation) ResetDigitalAddress() {
	m.digital_address = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *RetailMerchantMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *RetailMerchantMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *RetailMerchantMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *RetailMerchantMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *RetailMerchantMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *RetailMerchantMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// Where appends a list predicates to the RetailMerchantMutation builder.
func (m *RetailMerchantMutation) Where(ps ...predicate.RetailMerchant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RetailMerchantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RetailMerchant).
func (m *RetailMerchantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RetailMerchantMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, retailmerchant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, retailmerchant.FieldUpdatedAt)
	}
	if m.ghana_card != nil {
		fields = append(fields, retailmerchant.FieldGhanaCard)
	}
	if m.last_name != nil {
		fields = append(fields, retailmerchant.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, retailmerchant.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, retailmerchant.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, retailmerchant.FieldOtherPhone)
	}
	if m.address != nil {
		fields = append(fields, retailmerchant.FieldAddress)
	}
	if m.digital_address != nil {
		fields = append(fields, retailmerchant.FieldDigitalAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RetailMerchantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case retailmerchant.FieldCreatedAt:
		return m.CreatedAt()
	case retailmerchant.FieldUpdatedAt:
		return m.UpdatedAt()
	case retailmerchant.FieldGhanaCard:
		return m.GhanaCard()
	case retailmerchant.FieldLastName:
		return m.LastName()
	case retailmerchant.FieldOtherName:
		return m.OtherName()
	case retailmerchant.FieldPhone:
		return m.Phone()
	case retailmerchant.FieldOtherPhone:
		return m.OtherPhone()
	case retailmerchant.FieldAddress:
		return m.Address()
	case retailmerchant.FieldDigitalAddress:
		return m.DigitalAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RetailMerchantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case retailmerchant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case retailmerchant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case retailmerchant.FieldGhanaCard:
		return m.OldGhanaCard(ctx)
	case retailmerchant.FieldLastName:
		return m.OldLastName(ctx)
	case retailmerchant.FieldOtherName:
		return m.OldOtherName(ctx)
	case retailmerchant.FieldPhone:
		return m.OldPhone(ctx)
	case retailmerchant.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case retailmerchant.FieldAddress:
		return m.OldAddress(ctx)
	case retailmerchant.FieldDigitalAddress:
		return m.OldDigitalAddress(ctx)
	}
	return nil, fmt.Errorf("unknown RetailMerchant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetailMerchantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case retailmerchant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case retailmerchant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case retailmerchant.FieldGhanaCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGhanaCard(v)
		return nil
	case retailmerchant.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case retailmerchant.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case retailmerchant.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case retailmerchant.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case retailmerchant.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case retailmerchant.FieldDigitalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigitalAddress(v)
		return nil
	}
	return fmt.Errorf("unknown RetailMerchant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RetailMerchantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RetailMerchantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RetailMerchantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RetailMerchant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RetailMerchantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(retailmerchant.FieldOtherPhone) {
		fields = append(fields, retailmerchant.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RetailMerchantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RetailMerchantMutation) ClearField(name string) error {
	switch name {
	case retailmerchant.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown RetailMerchant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RetailMerchantMutation) ResetField(name string) error {
	switch name {
	case retailmerchant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case retailmerchant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case retailmerchant.FieldGhanaCard:
		m.ResetGhanaCard()
		return nil
	case retailmerchant.FieldLastName:
		m.ResetLastName()
		return nil
	case retailmerchant.FieldOtherName:
		m.ResetOtherName()
		return nil
	case retailmerchant.FieldPhone:
		m.ResetPhone()
		return nil
	case retailmerchant.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case retailmerchant.FieldAddress:
		m.ResetAddress()
		return nil
	case retailmerchant.FieldDigitalAddress:
		m.ResetDigitalAddress()
		return nil
	}
	return fmt.Errorf("unknown RetailMerchant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RetailMerchantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.merchant != nil {
		edges = append(edges, retailmerchant.EdgeMerchant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RetailMerchantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case retailmerchant.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RetailMerchantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RetailMerchantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RetailMerchantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmerchant {
		edges = append(edges, retailmerchant.EdgeMerchant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RetailMerchantMutation) EdgeCleared(name string) bool {
	switch name {
	case retailmerchant.EdgeMerchant:
		return m.clearedmerchant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RetailMerchantMutation) ClearEdge(name string) error {
	switch name {
	case retailmerchant.EdgeMerchant:
		m.ClearMerchant()
		return nil
	}
	return fmt.Errorf("unknown RetailMerchant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RetailMerchantMutation) ResetEdge(name string) error {
	switch name {
	case retailmerchant.EdgeMerchant:
		m.ResetMerchant()
		return nil
	}
	return fmt.Errorf("unknown RetailMerchant edge %s", name)
}

// SupplierMerchantMutation represents an operation that mutates the SupplierMerchant nodes in the graph.
type SupplierMerchantMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	ghana_card      *string
	last_name       *string
	other_name      *string
	phone           *string
	other_phone     *string
	address         *string
	digital_address *string
	clearedFields   map[string]struct{}
	merchant        *int
	clearedmerchant bool
	done            bool
	oldValue        func(context.Context) (*SupplierMerchant, error)
	predicates      []predicate.SupplierMerchant
}

var _ ent.Mutation = (*SupplierMerchantMutation)(nil)

// suppliermerchantOption allows management of the mutation configuration using functional options.
type suppliermerchantOption func(*SupplierMerchantMutation)

// newSupplierMerchantMutation creates new mutation for the SupplierMerchant entity.
func newSupplierMerchantMutation(c config, op Op, opts ...suppliermerchantOption) *SupplierMerchantMutation {
	m := &SupplierMerchantMutation{
		config:        c,
		op:            op,
		typ:           TypeSupplierMerchant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSupplierMerchantID sets the ID field of the mutation.
func withSupplierMerchantID(id int) suppliermerchantOption {
	return func(m *SupplierMerchantMutation) {
		var (
			err   error
			once  sync.Once
			value *SupplierMerchant
		)
		m.oldValue = func(ctx context.Context) (*SupplierMerchant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SupplierMerchant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSupplierMerchant sets the old SupplierMerchant of the mutation.
func withSupplierMerchant(node *SupplierMerchant) suppliermerchantOption {
	return func(m *SupplierMerchantMutation) {
		m.oldValue = func(context.Context) (*SupplierMerchant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SupplierMerchantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SupplierMerchantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SupplierMerchantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SupplierMerchantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SupplierMerchant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SupplierMerchantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SupplierMerchantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SupplierMerchantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SupplierMerchantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SupplierMerchantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SupplierMerchantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGhanaCard sets the "ghana_card" field.
func (m *SupplierMerchantMutation) SetGhanaCard(s string) {
	m.ghana_card = &s
}

// GhanaCard returns the value of the "ghana_card" field in the mutation.
func (m *SupplierMerchantMutation) GhanaCard() (r string, exists bool) {
	v := m.ghana_card
	if v == nil {
		return
	}
	return *v, true
}

// OldGhanaCard returns the old "ghana_card" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldGhanaCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGhanaCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGhanaCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGhanaCard: %w", err)
	}
	return oldValue.GhanaCard, nil
}

// ResetGhanaCard resets all changes to the "ghana_card" field.
func (m *SupplierMerchantMutation) ResetGhanaCard() {
	m.ghana_card = nil
}

// SetLastName sets the "last_name" field.
func (m *SupplierMerchantMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *SupplierMerchantMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *SupplierMerchantMutation) ResetLastName() {
	m.last_name = nil
}

// SetOtherName sets the "other_name" field.
func (m *SupplierMerchantMutation) SetOtherName(s string) {
	m.other_name = &s
}

// OtherName returns the value of the "other_name" field in the mutation.
func (m *SupplierMerchantMutation) OtherName() (r string, exists bool) {
	v := m.other_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherName returns the old "other_name" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldOtherName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherName: %w", err)
	}
	return oldValue.OtherName, nil
}

// ResetOtherName resets all changes to the "other_name" field.
func (m *SupplierMerchantMutation) ResetOtherName() {
	m.other_name = nil
}

// SetPhone sets the "phone" field.
func (m *SupplierMerchantMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SupplierMerchantMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *SupplierMerchantMutation) ResetPhone() {
	m.phone = nil
}

// SetOtherPhone sets the "other_phone" field.
func (m *SupplierMerchantMutation) SetOtherPhone(s string) {
	m.other_phone = &s
}

// OtherPhone returns the value of the "other_phone" field in the mutation.
func (m *SupplierMerchantMutation) OtherPhone() (r string, exists bool) {
	v := m.other_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherPhone returns the old "other_phone" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldOtherPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherPhone: %w", err)
	}
	return oldValue.OtherPhone, nil
}

// ClearOtherPhone clears the value of the "other_phone" field.
func (m *SupplierMerchantMutation) ClearOtherPhone() {
	m.other_phone = nil
	m.clearedFields[suppliermerchant.FieldOtherPhone] = struct{}{}
}

// OtherPhoneCleared returns if the "other_phone" field was cleared in this mutation.
func (m *SupplierMerchantMutation) OtherPhoneCleared() bool {
	_, ok := m.clearedFields[suppliermerchant.FieldOtherPhone]
	return ok
}

// ResetOtherPhone resets all changes to the "other_phone" field.
func (m *SupplierMerchantMutation) ResetOtherPhone() {
	m.other_phone = nil
	delete(m.clearedFields, suppliermerchant.FieldOtherPhone)
}

// SetAddress sets the "address" field.
func (m *SupplierMerchantMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *SupplierMerchantMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *SupplierMerchantMutation) ResetAddress() {
	m.address = nil
}

// SetDigitalAddress sets the "digital_address" field.
func (m *SupplierMerchantMutation) SetDigitalAddress(s string) {
	m.digital_address = &s
}

// DigitalAddress returns the value of the "digital_address" field in the mutation.
func (m *SupplierMerchantMutation) DigitalAddress() (r string, exists bool) {
	v := m.digital_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDigitalAddress returns the old "digital_address" field's value of the SupplierMerchant entity.
// If the SupplierMerchant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierMerchantMutation) OldDigitalAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigitalAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigitalAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigitalAddress: %w", err)
	}
	return oldValue.DigitalAddress, nil
}

// ResetDigitalAddress resets all changes to the "digital_address" field.
func (m *SupplierMerchantMutation) ResetDigitalAddress() {
	m.digital_address = nil
}

// SetMerchantID sets the "merchant" edge to the Merchant entity by id.
func (m *SupplierMerchantMutation) SetMerchantID(id int) {
	m.merchant = &id
}

// ClearMerchant clears the "merchant" edge to the Merchant entity.
func (m *SupplierMerchantMutation) ClearMerchant() {
	m.clearedmerchant = true
}

// MerchantCleared reports if the "merchant" edge to the Merchant entity was cleared.
func (m *SupplierMerchantMutation) MerchantCleared() bool {
	return m.clearedmerchant
}

// MerchantID returns the "merchant" edge ID in the mutation.
func (m *SupplierMerchantMutation) MerchantID() (id int, exists bool) {
	if m.merchant != nil {
		return *m.merchant, true
	}
	return
}

// MerchantIDs returns the "merchant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MerchantID instead. It exists only for internal usage by the builders.
func (m *SupplierMerchantMutation) MerchantIDs() (ids []int) {
	if id := m.merchant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMerchant resets all changes to the "merchant" edge.
func (m *SupplierMerchantMutation) ResetMerchant() {
	m.merchant = nil
	m.clearedmerchant = false
}

// Where appends a list predicates to the SupplierMerchantMutation builder.
func (m *SupplierMerchantMutation) Where(ps ...predicate.SupplierMerchant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SupplierMerchantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SupplierMerchant).
func (m *SupplierMerchantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SupplierMerchantMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, suppliermerchant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, suppliermerchant.FieldUpdatedAt)
	}
	if m.ghana_card != nil {
		fields = append(fields, suppliermerchant.FieldGhanaCard)
	}
	if m.last_name != nil {
		fields = append(fields, suppliermerchant.FieldLastName)
	}
	if m.other_name != nil {
		fields = append(fields, suppliermerchant.FieldOtherName)
	}
	if m.phone != nil {
		fields = append(fields, suppliermerchant.FieldPhone)
	}
	if m.other_phone != nil {
		fields = append(fields, suppliermerchant.FieldOtherPhone)
	}
	if m.address != nil {
		fields = append(fields, suppliermerchant.FieldAddress)
	}
	if m.digital_address != nil {
		fields = append(fields, suppliermerchant.FieldDigitalAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SupplierMerchantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case suppliermerchant.FieldCreatedAt:
		return m.CreatedAt()
	case suppliermerchant.FieldUpdatedAt:
		return m.UpdatedAt()
	case suppliermerchant.FieldGhanaCard:
		return m.GhanaCard()
	case suppliermerchant.FieldLastName:
		return m.LastName()
	case suppliermerchant.FieldOtherName:
		return m.OtherName()
	case suppliermerchant.FieldPhone:
		return m.Phone()
	case suppliermerchant.FieldOtherPhone:
		return m.OtherPhone()
	case suppliermerchant.FieldAddress:
		return m.Address()
	case suppliermerchant.FieldDigitalAddress:
		return m.DigitalAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SupplierMerchantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case suppliermerchant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case suppliermerchant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case suppliermerchant.FieldGhanaCard:
		return m.OldGhanaCard(ctx)
	case suppliermerchant.FieldLastName:
		return m.OldLastName(ctx)
	case suppliermerchant.FieldOtherName:
		return m.OldOtherName(ctx)
	case suppliermerchant.FieldPhone:
		return m.OldPhone(ctx)
	case suppliermerchant.FieldOtherPhone:
		return m.OldOtherPhone(ctx)
	case suppliermerchant.FieldAddress:
		return m.OldAddress(ctx)
	case suppliermerchant.FieldDigitalAddress:
		return m.OldDigitalAddress(ctx)
	}
	return nil, fmt.Errorf("unknown SupplierMerchant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMerchantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case suppliermerchant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case suppliermerchant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case suppliermerchant.FieldGhanaCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGhanaCard(v)
		return nil
	case suppliermerchant.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case suppliermerchant.FieldOtherName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherName(v)
		return nil
	case suppliermerchant.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case suppliermerchant.FieldOtherPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherPhone(v)
		return nil
	case suppliermerchant.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case suppliermerchant.FieldDigitalAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigitalAddress(v)
		return nil
	}
	return fmt.Errorf("unknown SupplierMerchant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SupplierMerchantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SupplierMerchantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierMerchantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SupplierMerchant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SupplierMerchantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(suppliermerchant.FieldOtherPhone) {
		fields = append(fields, suppliermerchant.FieldOtherPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SupplierMerchantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SupplierMerchantMutation) ClearField(name string) error {
	switch name {
	case suppliermerchant.FieldOtherPhone:
		m.ClearOtherPhone()
		return nil
	}
	return fmt.Errorf("unknown SupplierMerchant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SupplierMerchantMutation) ResetField(name string) error {
	switch name {
	case suppliermerchant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case suppliermerchant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case suppliermerchant.FieldGhanaCard:
		m.ResetGhanaCard()
		return nil
	case suppliermerchant.FieldLastName:
		m.ResetLastName()
		return nil
	case suppliermerchant.FieldOtherName:
		m.ResetOtherName()
		return nil
	case suppliermerchant.FieldPhone:
		m.ResetPhone()
		return nil
	case suppliermerchant.FieldOtherPhone:
		m.ResetOtherPhone()
		return nil
	case suppliermerchant.FieldAddress:
		m.ResetAddress()
		return nil
	case suppliermerchant.FieldDigitalAddress:
		m.ResetDigitalAddress()
		return nil
	}
	return fmt.Errorf("unknown SupplierMerchant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SupplierMerchantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.merchant != nil {
		edges = append(edges, suppliermerchant.EdgeMerchant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SupplierMerchantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case suppliermerchant.EdgeMerchant:
		if id := m.merchant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SupplierMerchantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SupplierMerchantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SupplierMerchantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmerchant {
		edges = append(edges, suppliermerchant.EdgeMerchant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SupplierMerchantMutation) EdgeCleared(name string) bool {
	switch name {
	case suppliermerchant.EdgeMerchant:
		return m.clearedmerchant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SupplierMerchantMutation) ClearEdge(name string) error {
	switch name {
	case suppliermerchant.EdgeMerchant:
		m.ClearMerchant()
		return nil
	}
	return fmt.Errorf("unknown SupplierMerchant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SupplierMerchantMutation) ResetEdge(name string) error {
	switch name {
	case suppliermerchant.EdgeMerchant:
		m.ResetMerchant()
		return nil
	}
	return fmt.Errorf("unknown SupplierMerchant edge %s", name)
}
